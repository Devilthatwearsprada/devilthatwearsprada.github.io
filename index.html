<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>80s Thermodynamics Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050510;
            --text-color: #dbeafe;
            --accent-color: #ff0055;
            --crt-scanline: rgba(255, 255, 255, 0.1);
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            user-select: none;
        }

        /* --- MENU STYLES --- */
        #main-menu {
            text-align: center;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            color: #fbbf24;
            text-shadow: 4px 4px #be123c;
            font-size: 24px;
            margin-bottom: 40px;
            line-height: 1.5;
        }

        .menu-btn {
            background: transparent;
            border: 2px solid #334155;
            color: #94a3b8;
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            width: 320px;
            margin: 0 auto;
        }

        .menu-btn:hover {
            border-color: #38bdf8;
            color: #fff;
            background: rgba(56, 189, 248, 0.1);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }

        /* --- GAME CONTAINER --- */
        #game-wrapper {
            display: none; /* Hidden by default */
            position: relative;
            border: 16px solid #2a2a3a;
            border-radius: 4px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* --- SHARED UI OVERLAYS --- */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
            animation: flicker 0.15s infinite;
        }
        
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,50,0.3) 100%);
            pointer-events: none;
            z-index: 51;
        }

        #game-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 52;
        }

        /* Dynamic UI Control Panel (Below Canvas) */
        #controls-area {
            display: none;
            margin-top: 20px;
            width: 640px;
            background: #111;
            padding: 15px;
            border: 2px solid #333;
            border-radius: 8px;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        #back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #be123c;
            border: none;
            color: white;
            padding: 10px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            z-index: 200;
            display: none;
        }
        
        #back-btn:hover { background: #e11d48; }

        @keyframes flicker {
            0% { opacity: 0.9; }
            50% { opacity: 1.0; }
            100% { opacity: 0.9; }
        }

        /* Helper for injected UI elements */
        .ui-label-top {
            position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-around;
            text-shadow: 2px 2px #000; font-size: 12px; text-transform: uppercase;
        }
        .ui-label-bottom {
            position: absolute; bottom: 10px; width: 100%; display: flex; justify-content: space-around;
            text-shadow: 2px 2px #000; font-size: 10px; color: #94a3b8;
        }
        
        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; background: #3b82f6;
            cursor: pointer; margin-top: -6px; box-shadow: 0 0 5px #3b82f6; border: 2px solid #fff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #333; border: 1px solid #555;
        }

    </style>
</head>
<body>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <h1>THERMODYNAMICS<br>ARCADE</h1>
        <button class="menu-btn" onclick="GameManager.load('snowstorm')">1. Chaos vs Order</button>
        <button class="menu-btn" onclick="GameManager.load('nutcracker')">2. Feedback Loops</button>
        <button class="menu-btn" onclick="GameManager.load('shutter')">3. Shutter Speed (Tau)</button>
        <button class="menu-btn" onclick="GameManager.load('wanderer')">4. The Wanderer</button>
    </div>

    <button id="back-btn" onclick="GameManager.exit()">EJECT CARTRIDGE</button>

    <!-- GAME AREA -->
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="640" height="320"></canvas>
        <div id="game-ui"></div> <!-- Injected UI Labels -->
        <div class="scanlines"></div>
        <div class="screen-overlay"></div>
    </div>

    <!-- CONTROLS AREA (Below Canvas) -->
    <div id="controls-area"></div>

    <script>
        // --- GAME ENGINE & STATE MANAGEMENT ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('game-ui');
        const controlsArea = document.getElementById('controls-area');
        
        let animationId = null;

        const GameManager = {
            activeGame: null,

            load: function(gameKey) {
                // Hide Menu, Show Game
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game-wrapper').style.display = 'block';
                document.getElementById('back-btn').style.display = 'block';
                
                // Clear previous state
                ctx.clearRect(0,0,canvas.width, canvas.height);
                uiLayer.innerHTML = '';
                controlsArea.innerHTML = '';
                controlsArea.style.display = 'none';

                // Initialize specific game
                if (games[gameKey]) {
                    this.activeGame = games[gameKey];
                    this.activeGame.init();
                    this.loop();
                }
            },

            exit: function() {
                if (animationId) cancelAnimationFrame(animationId);
                
                // Show Menu, Hide Game
                document.getElementById('main-menu').style.display = 'flex';
                document.getElementById('game-wrapper').style.display = 'none';
                document.getElementById('back-btn').style.display = 'none';
                controlsArea.style.display = 'none';
                
                // Cleanup
                this.activeGame = null;
                uiLayer.innerHTML = '';
                controlsArea.innerHTML = '';
            },

            loop: function() {
                if (!this.activeGame) return;
                this.activeGame.update();
                this.activeGame.draw();
                animationId = requestAnimationFrame(() => this.loop());
            }
        };

        // --- GAME LIBRARIES ---

        const games = {
            
            // --- GAME 1: SNOWSTORM (Chaos vs Order) ---
            snowstorm: {
                entities: [],
                snow: [],
                frameCount: 0,
                towerDirection: 0,
                lastShoutTime: 0,
                SCALE: 4,

                init: function() {
                    canvas.height = 320;
                    this.frameCount = 0;
                    this.entities = [];
                    this.snow = [];
                    
                    const WIDTH = canvas.width / this.SCALE;
                    const HEIGHT = canvas.height / this.SCALE;
                    const HALF_W = WIDTH / 2;

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #fff;">
                            <span>Scenario A: Chaos</span>
                            <span>Scenario B: Order</span>
                        </div>
                    `;

                    // Init Walkers
                    // Sim 1: Random
                    this.entities.push(this.createWalker((HALF_W/2)-2, HEIGHT/2, 'random'));
                    this.entities.push(this.createWalker((HALF_W/2)+2, HEIGHT/2, 'random'));
                    // Sim 2: Directed
                    this.entities.push(this.createWalker(HALF_W + (HALF_W/2), HEIGHT/2, 'directed'));

                    // Init Snow
                    for(let i=0; i<50; i++) {
                        this.snow.push({
                            x: Math.random() * WIDTH,
                            y: Math.random() * HEIGHT,
                            speed: 0.2 + Math.random() * 0.5
                        });
                    }
                },

                createWalker: function(x, y, type) {
                    return { x, y, type, update: function(frame, tDir, w, h, hw) {
                        if (frame % 10 !== 0) return;
                        let dx = 0, dy = 0, step = 2;
                        
                        if (this.type === 'random') {
                            const r = Math.floor(Math.random() * 4);
                            if (r===0) dy=-step; if (r===1) dx=step; if (r===2) dy=step; if (r===3) dx=-step;
                        } else {
                            if (tDir===0) dy=-step; if (tDir===1) dx=step; if (tDir===2) dy=step; if (tDir===3) dx=-step;
                        }
                        this.x += dx; this.y += dy;
                        
                        // Bounds
                        const margin = 2;
                        if (this.type === 'random') {
                            this.x = Math.max(margin, Math.min(hw-margin, this.x));
                        } else {
                            this.x = Math.max(hw+margin, Math.min(w-margin, this.x));
                        }
                        this.y = Math.max(margin, Math.min(h-margin, this.y));
                    }};
                },

                update: function() {
                    const WIDTH = canvas.width / this.SCALE;
                    const HEIGHT = canvas.height / this.SCALE;
                    const HALF_W = WIDTH / 2;
                    
                    this.frameCount++;

                    if (this.frameCount - this.lastShoutTime > 60) {
                        this.towerDirection = Math.floor(Math.random() * 4);
                        this.lastShoutTime = this.frameCount;
                    }

                    this.entities.forEach(e => e.update(this.frameCount, this.towerDirection, WIDTH, HEIGHT, HALF_W));
                    
                    // Snow
                    this.snow.forEach(p => {
                        p.y += p.speed;
                        p.x += Math.sin(this.frameCount * 0.05) * 0.5;
                        if(p.y > HEIGHT) p.y = 0;
                        if(p.x > WIDTH) p.x = 0;
                    });
                },

                draw: function() {
                    const WIDTH = canvas.width / this.SCALE;
                    const HEIGHT = canvas.height / this.SCALE;
                    const HALF_W = WIDTH / 2;

                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.scale(this.SCALE, this.SCALE);

                    // Backgrounds
                    ctx.fillStyle = '#F0E68C'; ctx.fillRect(0,0,HALF_W, HEIGHT); // Left
                    ctx.fillRect(HALF_W,0,HALF_W, HEIGHT); // Right
                    
                    // Safe Zones
                    ctx.fillStyle = '#32CD32';
                    const sz = 40;
                    ctx.fillRect((HALF_W/2)-sz/2, (HEIGHT/2)-sz/2, sz, sz);
                    ctx.fillRect(HALF_W+(HALF_W/2)-sz/2, (HEIGHT/2)-sz/2, sz, sz);

                    // Divider
                    ctx.fillStyle = '#000'; ctx.fillRect(HALF_W-1, 0, 2, HEIGHT);

                    // Snow
                    ctx.fillStyle = '#FFF';
                    this.snow.forEach(p => ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1));

                    // Tower (Right Side)
                    const tx = WIDTH - 20, ty = 20;
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(tx, ty, 8, 12); // Base
                    ctx.fillRect(tx-1, ty, 10, 2); // Top
                    ctx.fillStyle = '#1E90FF'; ctx.fillRect(tx+2, ty-3, 4, 4); // Hood

                    // Bubble
                    this.drawBubble(tx-14, ty-8, this.towerDirection);

                    // Walkers
                    ctx.fillStyle = '#000';
                    this.entities.forEach(e => {
                        ctx.fillRect(e.x, e.y, 3, 3);
                        ctx.fillRect(e.x+1, e.y-1, 1, 1);
                    });
                },

                drawBubble: function(x, y, dir) {
                    ctx.fillStyle = '#FFF'; ctx.strokeStyle='#000'; ctx.lineWidth=1;
                    ctx.fillRect(x,y,12,11); ctx.strokeRect(x,y,12,11);
                    // Arrow
                    ctx.fillStyle = '#000';
                    const cx = x+6, cy=y+5.5;
                    ctx.beginPath();
                    if(dir===0) { ctx.moveTo(cx,cy-3); ctx.lineTo(cx-2,cy); ctx.lineTo(cx+2,cy); }
                    else if(dir===1) { ctx.moveTo(cx+3,cy); ctx.lineTo(cx,cy-2); ctx.lineTo(cx,cy+2); }
                    else if(dir===2) { ctx.moveTo(cx,cy+3); ctx.lineTo(cx-2,cy); ctx.lineTo(cx+2,cy); }
                    else { ctx.moveTo(cx-3,cy); ctx.lineTo(cx,cy-2); ctx.lineTo(cx,cy+2); }
                    ctx.fill();
                }
            },


            // --- GAME 2: NUTCRACKER (Feedback) ---
            nutcracker: {
                frameCount: 0,
                SCALE: 4,
                angle: 0, soldierAngle: 0,
                history: [],
                sweat: [], snow: [],

                init: function() {
                    canvas.height = 320;
                    this.frameCount = 0;
                    this.angle = 0;
                    this.soldierAngle = 0;
                    this.history = [];
                    this.sweat = [];
                    this.snow = [];
                    
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #fbbf24;">
                            <span>Feedback Loop</span>
                            <span>Zero Feedback</span>
                        </div>
                        <div class="ui-label-bottom">
                            <span>Shared Energy</span>
                            <span>Heat &Phi; = Cost</span>
                        </div>
                    `;

                    for(let i=0; i<40; i++) {
                        this.snow.push({ x: Math.random()*WIDTH, y: Math.random()*HEIGHT, speed: 0.1+Math.random()*0.4});
                    }
                },

                update: function() {
                    this.frameCount++;
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;
                    
                    // Logic Left (Dancers)
                    this.angle += 0.05;

                    // Logic Right (Soldier/Mime)
                    const radius = 20;
                    const center2X = (WIDTH/2) + (WIDTH/4);
                    const center2Y = HEIGHT/2 + 10;
                    
                    this.soldierAngle += 0.04;
                    const sX = center2X + Math.cos(this.soldierAngle) * (radius*0.8);
                    const sY = center2Y + Math.sin(this.soldierAngle) * (radius*0.4) + 5;
                    const sFlip = Math.sin(this.soldierAngle) > 0;

                    this.history.push({x:sX, y:sY, flip:sFlip});
                    if(this.history.length > 26) this.history.shift();

                    // Sweat
                    if(this.history.length >= 25 && this.frameCount % 10 === 0) {
                        const past = this.history[0];
                        this.sweat.push({ x: past.x, y: past.y-8, vx: (Math.random()-0.5), vy: -0.5-Math.random() });
                    }
                    for(let i=this.sweat.length-1; i>=0; i--) {
                        this.sweat[i].x += this.sweat[i].vx;
                        this.sweat[i].y += this.sweat[i].vy;
                        this.sweat[i].vy += 0.05;
                        if(this.sweat[i].y > HEIGHT) this.sweat.splice(i,1);
                    }

                    // Snow
                    this.snow.forEach(p => {
                        p.y += p.speed; p.x += Math.sin(this.frameCount*0.02)*0.2;
                        if(p.y>HEIGHT) p.y=0; if(p.x>WIDTH) p.x=0;
                    });
                },

                draw: function() {
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;
                    const HALF_W = WIDTH/2;
                    const centerX = HALF_W/2;
                    const centerY = HEIGHT/2 + 10;
                    const radius = 20;

                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.scale(this.SCALE, this.SCALE);

                    // BG Left
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(0,0,HALF_W, HEIGHT);
                    ctx.fillStyle = '#e0f2fe'; ctx.beginPath(); ctx.ellipse(centerX, centerY+8, 28, 13, 0, 0, Math.PI*2); ctx.fill();
                    
                    // BG Right
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(HALF_W,0,HALF_W, HEIGHT);
                    ctx.fillStyle = '#e2e8f0'; ctx.beginPath(); ctx.ellipse(centerX+HALF_W, centerY+8, 28, 13, 0, 0, Math.PI*2); ctx.fill();
                    
                    // Divider
                    ctx.fillStyle = '#000'; ctx.fillRect(HALF_W-1, 0, 2, HEIGHT);

                    // --- Left Dancers ---
                    const d1X = centerX + Math.cos(this.angle)*(radius*0.7);
                    const d1Y = centerY + Math.sin(this.angle)*(radius*0.35)+5;
                    const d2X = centerX + Math.cos(this.angle+Math.PI)*(radius*0.7);
                    const d2Y = centerY + Math.sin(this.angle+Math.PI)*(radius*0.35)+5;
                    
                    const drawDancer = (x,y) => {
                        ctx.fillStyle = '#f472b6'; ctx.fillRect(x-3, y+2, 7, 3); // Dress
                        ctx.fillStyle = '#ffe4e6'; ctx.fillRect(x, y-3, 2, 2); // Head
                    };
                    
                    if (Math.sin(this.angle) < 0) { drawDancer(d1X,d1Y); drawDancer(d2X,d2Y); }
                    else { drawDancer(d2X,d2Y); drawDancer(d1X,d1Y); }
                    
                    ctx.strokeStyle = '#fbcfe8'; ctx.beginPath(); ctx.moveTo(d1X+1, d1Y+2); ctx.lineTo(d2X+1, d2Y+2); ctx.stroke();

                    // --- Right Soldier/Mime ---
                    // Current Pos
                    const center2X = centerX+HALF_W;
                    const center2Y = centerY;
                    const sX = center2X + Math.cos(this.soldierAngle) * (radius*0.8);
                    const sY = center2Y + Math.sin(this.soldierAngle) * (radius*0.4) + 5;
                    const sFlip = Math.sin(this.soldierAngle) > 0;
                    
                    const entities = [{t:'s', x:sX, y:sY, f:sFlip}];
                    if(this.history.length >= 25) {
                         const h = this.history[0];
                         entities.push({t:'m', x:h.x, y:h.y, f:h.f});
                    }
                    entities.sort((a,b)=>a.y-b.y);

                    entities.forEach(e => {
                        ctx.save(); ctx.translate(e.x, e.y); if(e.f) ctx.scale(-1,1);
                        if(e.t==='s') {
                            ctx.fillStyle = '#ef4444'; ctx.fillRect(-3, 2, 6, 6); // Coat
                            ctx.fillStyle = '#000'; ctx.fillRect(-2, -6, 4, 5); // Hat
                        } else {
                            ctx.fillStyle = '#fff'; ctx.fillRect(-2, 0, 5, 6); // Shirt
                            ctx.fillStyle = '#334155'; ctx.fillRect(-2, 1, 5, 1); // Stripe
                            ctx.fillStyle = '#000'; ctx.fillRect(-2, -5, 5, 2); // Beret
                        }
                        ctx.restore();
                    });

                    // Sweat
                    ctx.fillStyle = '#0ea5e9';
                    this.sweat.forEach(p => ctx.fillRect(p.x, p.y, 1, 1));
                    
                    // Global Snow
                    ctx.fillStyle = '#fff';
                    this.snow.forEach(p => ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1));
                }
            },


            // --- GAME 3: SHUTTER SPEED (Tau) ---
            shutter: {
                frameCount: 0, SCALE: 4, tau: 0.5,
                
                init: function() {
                    canvas.height = 320;
                    this.frameCount = 0;
                    this.tau = 0.5;

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #ff0055; text-align: left; padding-left: 10px;">TARGET: SPEEDING CAR</div>
                        <div id="status-label" style="position:absolute; bottom:20px; width:100%; text-align:center; color:#fff; font-size:12px; text-shadow:2px 2px #000;">WAITING...</div>
                    `;

                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `
                         <div style="display:flex; flex-direction:column; width:100%; align-items:center;">
                            <div style="display:flex; justify-content:space-between; width:100%; color:#94a3b8; font-size:10px; margin-bottom:5px;">
                                <span>Noise (&tau;&rarr;0)</span>
                                <span>Causal Peak</span>
                                <span>Memory Loss (&tau;&rarr;&infin;)</span>
                            </div>
                            <input type="range" id="shutterSlider" min="0" max="100" value="50">
                            <div style="font-size:10px; color:#666; margin-top:5px;">ADJUST OBSERVATION TIME (&tau;)</div>
                         </div>
                    `;
                    
                    document.getElementById('shutterSlider').addEventListener('input', (e) => {
                        this.tau = parseInt(e.target.value) / 100;
                    });
                },

                update: function() {
                    this.frameCount++;
                    const lbl = document.getElementById('status-label');
                    if(this.tau < 0.2) { lbl.innerText = "NOISE DOMINANCE (Zoomed, High Entropy)"; lbl.style.color="#ef4444"; }
                    else if(this.tau > 0.8) { lbl.innerText = "MEMORY LOSS (Signal Departed)"; lbl.style.color="#64748b"; }
                    else { lbl.innerText = "CAUSAL PEAK (Signal Captured)"; lbl.style.color="#32CD32"; }
                },

                draw: function() {
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;
                    
                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    
                    // 1. Scene (Low Res)
                    ctx.scale(this.SCALE, this.SCALE);
                    
                    // BG
                    ctx.fillStyle = '#111'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,WIDTH,HEIGHT/2); // Sky
                    ctx.fillStyle = '#333'; ctx.fillRect(0,HEIGHT/2,WIDTH,HEIGHT/2); // Ground
                    
                    // Road
                    ctx.fillStyle = '#555';
                    const speed = (this.frameCount*4)%40;
                    for(let i=-40; i<WIDTH; i+=40) ctx.fillRect(i-speed, HEIGHT/2+20, 20, 2);

                    // Car Logic
                    const cx = (WIDTH/2)-15, cy = (HEIGHT/2)+10;
                    let zoom=1, blur=0, opacity=1;
                    
                    if(this.tau < 0.5) {
                        zoom = 1 + (1-(this.tau*2))*11;
                    } else {
                        const f = (this.tau-0.5)*2;
                        opacity = 1-f; blur = f*5;
                    }

                    // Draw Car
                    ctx.save();
                    if(zoom>1) {
                         ctx.translate(cx+10, cy+10); ctx.scale(zoom, zoom); ctx.translate(-(cx+10), -(cy+10));
                    }
                    const layers = 1+Math.floor(blur*10);
                    const step = blur*2;
                    for(let i=0; i<layers; i++) {
                        ctx.globalAlpha = opacity * (1-(i/layers));
                        const dx = cx - (i*step);
                        ctx.fillStyle = '#ef4444'; ctx.fillRect(dx, cy, 30, 10); // Body
                        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(dx+5, cy-6, 18, 6); // Cabin
                        ctx.fillStyle = '#93c5fd'; ctx.fillRect(dx+16, cy-5, 6, 4); // Glass
                        ctx.fillStyle = '#fbbf24'; ctx.fillRect(dx, cy+4, 30, 2); // Stripe
                        ctx.fillStyle = '#111'; ctx.fillRect(dx+4, cy+8, 6,6); ctx.fillRect(dx+20, cy+8, 6,6); // Wheels
                    }
                    ctx.restore();
                    
                    // 2. Noise (High Res)
                    ctx.setTransform(1,0,0,1,0,0);
                    if(this.tau < 0.5) {
                        const amount = (0.5-this.tau)*0.6; // max 30%
                        const id = ctx.getImageData(0,0,canvas.width,canvas.height);
                        const d = id.data;
                        for(let i=0; i<d.length; i+=4) {
                            if(Math.random()<amount) {
                                const v = Math.random()*255; d[i]=v; d[i+1]=v; d[i+2]=v;
                            }
                        }
                        ctx.putImageData(id, 0,0);
                    }
                }
            },


            // --- GAME 4: THE WANDERER (Rope Physics) ---
            wanderer: {
                frameCount:0, SCALE:2,
                ropeLen: 40, wSpeed: 2,
                wanderer: {x:0, y:0, a:0, ta:0, t:0},
                sled: {x:0, y:0, a:0},
                particles: [], totalHeat: 0,
                snowCanvas: null, snowCtx: null,

                init: function() {
                    canvas.height = 360; // Larger height for this one
                    this.frameCount = 0;
                    this.totalHeat = 0;
                    this.particles = [];
                    this.ropeLen = 40;
                    this.wSpeed = 2;

                    const WIDTH = canvas.width; 
                    const HEIGHT = canvas.height; 

                    this.wanderer = {x:WIDTH/2, y:HEIGHT/2, a:0, ta:0, t:0};
                    this.sled = {x:WIDTH/2, y:HEIGHT/2+40, a:0};

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #1e3a8a;">
                            <span>Signal (x): Wanderer</span>
                            <span>Response (y): Sled</span>
                        </div>
                        <div class="ui-label-bottom">
                            <span id="wand-math">Heat &Phi; &ge; Info T</span>
                        </div>
                    `;

                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `
                         <div style="width:45%;">
                            <label style="color:#94a3b8; font-size:10px;">Rope Length (Lag)</label>
                            <input type="range" id="ropeSlider" min="10" max="100" value="40">
                         </div>
                         <div style="width:45%;">
                            <label style="color:#94a3b8; font-size:10px;">Wanderer Speed</label>
                            <input type="range" id="speedSlider" min="1" max="10" value="3">
                         </div>
                    `;

                    document.getElementById('ropeSlider').addEventListener('input', e => this.ropeLen=parseInt(e.target.value));
                    document.getElementById('speedSlider').addEventListener('input', e => this.wSpeed=parseInt(e.target.value));
                    
                    // Create an offscreen canvas for persistent tracks
                    this.snowCanvas = document.createElement('canvas');
                    this.snowCanvas.width = WIDTH;
                    this.snowCanvas.height = HEIGHT;
                    this.snowCtx = this.snowCanvas.getContext('2d');
                    this.snowCtx.fillStyle = '#f0f9ff';
                    this.snowCtx.fillRect(0,0,WIDTH,HEIGHT);
                },

                update: function() {
                    this.frameCount++;
                    const WIDTH = canvas.width;
                    const HEIGHT = canvas.height;

                    // Wanderer
                    if(this.frameCount > this.wanderer.t) {
                        this.wanderer.ta = Math.random()*Math.PI*2;
                        this.wanderer.t = this.frameCount + 30 + Math.random()*60;
                    }
                    const diff = this.wanderer.ta - this.wanderer.a;
                    this.wanderer.a += diff*0.05;
                    this.wanderer.x += Math.cos(this.wanderer.a)*this.wSpeed;
                    this.wanderer.y += Math.sin(this.wanderer.a)*this.wSpeed;
                    
                    // Bounds
                    if(this.wanderer.x < 20 || this.wanderer.x > WIDTH-20) { this.wanderer.a = Math.PI - this.wanderer.a; this.wanderer.x = Math.max(20, Math.min(WIDTH-20, this.wanderer.x)); }
                    if(this.wanderer.y < 20 || this.wanderer.y > HEIGHT-20) { this.wanderer.a = -this.wanderer.a; this.wanderer.y = Math.max(20, Math.min(HEIGHT-20, this.wanderer.y)); }

                    // Sled
                    const dx = this.wanderer.x - this.sled.x;
                    const dy = this.wanderer.y - this.sled.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    let heatGen = 0;

                    if(dist > this.ropeLen) {
                        const angle = Math.atan2(dy, dx);
                        const tx = this.wanderer.x - Math.cos(angle)*this.ropeLen;
                        const ty = this.wanderer.y - Math.sin(angle)*this.ropeLen;
                        
                        const mx = (tx - this.sled.x)*0.1;
                        const my = (ty - this.sled.y)*0.1;
                        
                        const prevX = this.sled.x;
                        const prevY = this.sled.y;
                        this.sled.x += mx; this.sled.y += my;
                        this.sled.a = Math.atan2(my, mx);

                        // Tracks
                        this.snowCtx.strokeStyle = '#cbd5e1'; this.snowCtx.lineWidth=6; this.snowCtx.lineCap='round';
                        this.snowCtx.beginPath(); this.snowCtx.moveTo(prevX, prevY); this.snowCtx.lineTo(this.sled.x, this.sled.y); this.snowCtx.stroke();

                        // Heat
                        const moved = Math.sqrt(mx*mx+my*my);
                        heatGen = moved * 2;
                        if(moved > 0.5) {
                            for(let i=0; i<Math.floor(moved); i++) {
                                this.particles.push({x:this.sled.x, y:this.sled.y, vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2, life:1});
                            }
                        }
                    }

                    this.totalHeat += heatGen;
                    document.getElementById('wand-math').innerText = `Entropy Generated (\u03A6): ${Math.floor(this.totalHeat)}`;

                    // Particles
                    for(let i=this.particles.length-1; i>=0; i--) {
                        let p = this.particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
                        if(p.life<=0) this.particles.splice(i,1);
                    }
                },

                draw: function() {
                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.drawImage(this.snowCanvas, 0, 0);

                    // Rope
                    ctx.strokeStyle = '#0f172a'; ctx.lineWidth=2; ctx.setLineDash([4,4]);
                    ctx.beginPath(); ctx.moveTo(this.wanderer.x, this.wanderer.y); ctx.lineTo(this.sled.x, this.sled.y); ctx.stroke(); ctx.setLineDash([]);

                    // Sled
                    ctx.save(); ctx.translate(this.sled.x, this.sled.y); ctx.rotate(this.sled.a);
                    ctx.fillStyle = '#0284c7'; ctx.fillRect(-10,-5,20,10);
                    ctx.fillStyle = '#0c4a6e'; ctx.fillRect(-10,-8,20,2); ctx.fillRect(-10,6,20,2);
                    ctx.restore();

                    // Wanderer
                    ctx.save(); ctx.translate(this.wanderer.x, this.wanderer.y);
                    const bob = Math.sin(this.frameCount*0.2)*2;
                    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(0,10,8,4,0,0,Math.PI*2); ctx.fill(); // Shadow
                    ctx.fillStyle = '#dc2626'; ctx.fillRect(-6, -10+bob, 12, 14); // Body
                    ctx.fillStyle = '#fecaca'; ctx.fillRect(-4, -18+bob, 8, 8); // Head
                    ctx.fillStyle = '#991b1b'; ctx.fillRect(-5, -20+bob, 10, 4); // Hat
                    ctx.restore();

                    // Heat
                    ctx.fillStyle = '#f59e0b';
                    this.particles.forEach(p => { ctx.globalAlpha=p.life; ctx.fillRect(p.x, p.y, 2, 2); });
                    ctx.globalAlpha = 1;
                }
            }
        };

    </script>
</body>
</html>
