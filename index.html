<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>80s Thermodynamics Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050510;
            --text-color: #dbeafe;
            --accent-color: #ff0055;
            --crt-scanline: rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow-x: hidden;
            overflow-y: auto;
            user-select: none;
            padding: 20px 10px;
        }

        /* --- MENU STYLES --- */
        #main-menu {
            text-align: center;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #fbbf24;
            text-shadow: 4px 4px #be123c;
            font-size: clamp(16px, 5vw, 24px);
            margin-bottom: 30px;
            line-height: 1.5;
            padding: 0 10px;
        }

        .menu-btn {
            background: transparent;
            border: 2px solid #334155;
            color: #94a3b8;
            padding: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(10px, 3vw, 12px);
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            width: 90%;
            max-width: 450px;
            margin: 0 auto;
        }

        .menu-btn:active, .menu-btn:hover {
            border-color: #38bdf8;
            color: #fff;
            background: rgba(56, 189, 248, 0.1);
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }
        
        .special-btn {
            border-color: #ef4444;
            color: #fca5a5;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.2);
        }
        .special-btn:hover {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }

        /* --- GAME CONTAINER --- */
        #game-wrapper {
            display: none;
            position: relative;
            border: 8px solid #2a2a3a;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background: #000;
            margin-top: 10px;
            width: 100%;
            max-width: 640px;
        }

        @media (min-width: 600px) {
            #game-wrapper {
                border-width: 16px;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            }
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: auto;
        }

        /* --- SHARED UI OVERLAYS --- */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
            animation: flicker 0.15s infinite;
            opacity: 0.5;
        }
        
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,50,0.3) 100%);
            pointer-events: none;
            z-index: 51;
        }

        #game-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 52;
        }

        /* Dynamic UI Control Panel (Below Canvas) */
        #controls-area {
            display: none;
            margin-top: 15px;
            width: 100%;
            max-width: 640px;
            background: #111;
            padding: 15px;
            border: 2px solid #333;
            border-radius: 8px;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Description Area */
        #description-area {
            display: none;
            margin-top: 15px;
            width: 100%;
            max-width: 640px;
            background: #0f172a;
            border: 1px solid #1e293b;
            padding: 15px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
            color: #94a3b8;
            white-space: pre-wrap;
            border-radius: 4px;
            margin-bottom: 30px;
        }

        #description-area h3 {
            color: #38bdf8;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            margin-top: 0;
            margin-bottom: 10px;
            text-transform: uppercase;
            border-bottom: 1px solid #334155;
            padding-bottom: 8px;
        }

        #description-area strong { color: #e2e8f0; }
        #description-area em { color: #fbbf24; font-style: normal; }
        
        .narrative-text {
            color: #dbeafe;
            margin-bottom: 15px;
            font-style: italic;
            border-left: 3px solid #fbbf24;
            padding-left: 10px;
        }
        
        .variable-text {
            color: #94a3b8;
            font-size: 10px;
        }

        #back-btn {
            background: #be123c;
            border: none;
            color: white;
            padding: 12px 16px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            z-index: 200;
            display: none;
            margin-bottom: 10px;
            width: 100%;
            max-width: 640px;
            text-align: center;
            border-radius: 4px;
        }
        
        #back-btn:hover { background: #e11d48; }

        @keyframes flicker {
            0% { opacity: 0.9; }
            50% { opacity: 1.0; }
            100% { opacity: 0.9; }
        }

        .ui-label-top {
            position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-around;
            text-shadow: 2px 2px #000; font-size: clamp(8px, 2.5vw, 12px); text-transform: uppercase;
            padding: 0 5px;
        }
        .ui-label-bottom {
            position: absolute; bottom: 10px; width: 100%; display: flex; justify-content: space-around;
            text-shadow: 2px 2px #000; font-size: clamp(7px, 2.5vw, 10px); color: #94a3b8;
            padding: 0 5px;
        }
        
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 10px 0; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; background: #3b82f6;
            cursor: pointer; margin-top: -10px; box-shadow: 0 0 5px #3b82f6; border: 2px solid #fff;
            border-radius: 50%;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #333; border: 1px solid #555;
        }

        .control-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        
        @media (min-width: 600px) {
            .control-group {
                width: 45%;
                margin-bottom: 0;
            }
        }

        .hud-bar {
            position: absolute; top: 40px; right: 10px; width: 20px; height: 100px;
            border: 2px solid #555; background: #111;
        }
        .hud-fill { width: 100%; position: absolute; bottom: 0; transition: height 0.1s; }
        .key-hint {
            color: #666; font-size: 8px; text-align: center; margin-top: 5px;
        }
        
        .rev-btn {
            background: #22c55e; color: #000; font-family: inherit; font-size: 10px;
            border: 2px solid #fff; padding: 10px; cursor: pointer; text-transform: uppercase;
            margin-top: 10px; width: 100%;
        }
        .rev-btn:active { background: #15803d; color: #fff; }
        .rev-active { background: #ef4444 !important; color: #fff !important; animation: flicker 0.2s infinite; }

    </style>
</head>
<body>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <h1>THERMODYNAMICS<br>ARCADE</h1>
        <button class="menu-btn" onclick="GameManager.load('snowstorm')">1. Chaos vs Order</button>
        <button class="menu-btn" onclick="GameManager.load('nutcracker')">2. Feedback Loops</button>
        <button class="menu-btn" onclick="GameManager.load('shutter')">3. Shutter Speed (Tau)</button>
        <button class="menu-btn" onclick="GameManager.load('wanderer')">4. The Wanderer (Linear)</button>
        <button class="menu-btn" onclick="GameManager.load('chimney')">5. Blind Rudolph (Non-Linear)</button>
        <button class="menu-btn special-btn" onclick="GameManager.load('signalRunner')">6. Receptor Dynamics</button>
    </div>

    <!-- Eject Button -->
    <button id="back-btn" onclick="GameManager.exit()">EJECT CARTRIDGE (BACK TO MENU)</button>

    <!-- GAME AREA -->
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="640" height="320"></canvas>
        <div id="game-ui"></div> <!-- Injected UI Labels -->
        <div class="scanlines"></div>
        <div class="screen-overlay"></div>
    </div>

    <!-- CONTROLS AREA -->
    <div id="controls-area"></div>

    <!-- DESCRIPTION AREA -->
    <div id="description-area"></div>

    <script>
        // --- GAME ENGINE & STATE MANAGEMENT ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('game-ui');
        const controlsArea = document.getElementById('controls-area');
        const descriptionArea = document.getElementById('description-area');
        
        let animationId = null;
        let keys = {};

        window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

        // --- DESCRIPTIONS ---
        const descriptions = {
            snowstorm: `<h3>1. Chaos vs. Order (The Snowstorm)</h3>
<div class="narrative-text">
    "Look closely at the Snowstorm. In Scenario A (Chaos), both walkers are blind. They drift randomly. Mutual Information is zero. They burn energy, but produce no order.<br><br>
    In Scenario B (Order), the Red Leader stands <strong>outside</strong> the storm (Safe Zone), shouting directions. The Blue dot is trapped inside, fighting the noise. To maintain correlation, the Follower must constantly correct its path. Order is expensive."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Signal):</strong> The Red Leader (Safe Zone). Moves with intent.<br>
    <strong><em>y</em> (Response):</strong> The Blue Follower (Storm Zone).<br>
    <strong><em>D</em> (Diffusion/Noise):</strong> The green data-snow.<br>
    <strong>Visual Proof:</strong> Scenario A: T=0. Scenario B: Correlation exists but costs energy.
</div>`,

            nutcracker: `<h3>2. Feedback Loops (The Nutcracker)</h3>
<div class="narrative-text">
    "On the left, a Feedback Loop (Dancers). They share energy. The system is 'symmetric.'<br><br>
    On the right, Signal-Response (Soldier & Mime). The Soldier (<em>x</em>) ignores the Mime (<em>y</em>). The Mime is desperate to copy the history. Watch the Mime sweat. That sweat is Mapping Irreversibility (&Phi;). You cannot have the copy without the cost."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong>Topology:</strong> Left: &part;g<sub>x</sub>/&part;y &ne; 0. Right: &part;g<sub>x</sub>/&part;y = 0.<br>
    <strong>&Phi; (Irreversibility):</strong> Blue Sweat Drops (Heat).<br>
    <strong>T (Memory):</strong> The Mime’s Pose.
</div>`,

            shutter: `<h3>3. Shutter Speed (The Car Crash)</h3>
<div class="narrative-text">
    "How much heat does observation generate? It depends on shutter speed (&tau;).<br>
    <strong>Noise (&tau; &rarr; 0):</strong> Vibrating pixels. High energy, zero info.<br>
    <strong>Amnesia (&tau; &rarr; &infin;):</strong> Correlation decays to zero.<br>
    <strong>The Causal Peak (&tau; &approx; 0.5):</strong> The motion blur creates a vector (Arrow of Time). Biology lives here."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong>&tau; (Tau):</strong> Time gap between snapshots.<br>
    <strong>Blur:</strong> Visualizes x<sub>t</sub> vs x<sub>t+&tau;</sub>.
</div>`,

            wanderer: `<h3>4. The Wanderer (Linear Response)</h3>
<div class="narrative-text">
    "Watch the Red Wanderer. Every step creates a History. The Blue Sled tries to follow. The Drag—the friction resisting movement—is Mapping Irreversibility (&Phi;). You cannot carve tracks (store history) without enduring drag. Memory is friction."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Signal):</strong> Red Wanderer.<br>
    <strong><em>y</em> (Response):</strong> Blue Sled.<br>
    <strong>&beta; (Relaxation):</strong> Rope Stiffness.<br>
    <strong>&Phi; (Entropy):</strong> Orange Particles (Heat). &Phi; &ge; T.
    <strong>Reverse:</strong> Press the button to reverse time. Notice how the tracks vanish. This violates entropy!
</div>`,

            chimney: `<h3>5. Blind Rudolph & Guy (Non-Linear)</h3>
<div class="narrative-text">
    "<strong>The Audit:</strong> Rudolph ($x$) is flying blind in 2D space. Guy the Reindeer ($y$) is trapped in a CAGE. <br><br>
    <strong>The Rope on a Spool (&beta;):</strong> Use the slider to unwind the rope. <br>
    &bull; <strong>Short Rope:</strong> Guy slams against the cage bars. High Heat, High Info (You know where Rudolph is relative to the cage).<br>
    &bull; <strong>Long Rope:</strong> Guy sits still. Zero Heat, Zero Info. <br>
    <strong>Time Reverse:</strong> Press the button. The tracks vanish. The system runs backward, violating physics."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Signal):</strong> Rudolph (Red). 2D Random Walk.<br>
    <strong><em>y</em> (Response):</strong> Guy (Blue). Constrained by CAGE.<br>
    <strong>Cage:</strong> Saturation Limits. <br>
    <strong>Rope on Spool:</strong> Coupling Strength (&beta;).
</div>`,

            signalRunner: `<h3>6. Receptor Dynamics</h3>
<div class="narrative-text">
    "<strong>Biophysics Simulation:</strong> This graph visualizes the stochastic battle between a Signal (Red) and a Receptor Population (Blue).<br><br>
    <strong>Control Variables:</strong><br>
    1. <strong>[L] Ligand:</strong> The strength of the chemical signal.<br>
    2. <strong>&beta; (Relaxation):</strong> How expensive is it to switch? (Heat/Stiffness).<br>
    3. <strong>&tau; (Tau):</strong> The time lag for calculating information correlation.<br>
    <strong>Inequality:</strong> Watch the bottom ratio. Entropy (&Phi;) is always greater than Information (T)."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Red Line):</strong> Ligand Conc.<br>
    <strong><em>y</em> (Blue Area):</strong> Bound Receptors (0-100%).<br>
    <strong>Yellow Line:</strong> Time Lag (&tau;).
</div>`
        };

        const GameManager = {
            activeGame: null,

            load: function(gameKey) {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game-wrapper').style.display = 'block';
                document.getElementById('back-btn').style.display = 'block';
                
                ctx.clearRect(0,0,canvas.width, canvas.height);
                uiLayer.innerHTML = '';
                controlsArea.innerHTML = '';
                controlsArea.style.display = 'none';

                if (descriptions[gameKey]) {
                    descriptionArea.innerHTML = descriptions[gameKey];
                    descriptionArea.style.display = 'block';
                }

                if (games[gameKey]) {
                    this.activeGame = games[gameKey];
                    this.activeGame.init();
                    this.loop();
                }
            },

            exit: function() {
                if (animationId) cancelAnimationFrame(animationId);
                document.getElementById('main-menu').style.display = 'flex';
                document.getElementById('game-wrapper').style.display = 'none';
                document.getElementById('back-btn').style.display = 'none';
                controlsArea.style.display = 'none';
                descriptionArea.style.display = 'none';
                this.activeGame = null;
                uiLayer.innerHTML = '';
            },

            loop: function() {
                if (!this.activeGame) return;
                this.activeGame.update();
                this.activeGame.draw();
                animationId = requestAnimationFrame(() => this.loop());
            }
        };

        // --- GAME LIBRARIES ---

        const games = {
            
            // --- GAME 1: SNOWSTORM ---
            snowstorm: {
                entities: [], snow: [], frameCount: 0, SCALE: 4, towerDirection: 0, lastShoutTime: 0,
                init: function() {
                    canvas.height = 320; this.frameCount=0; this.entities=[]; this.snow=[];
                    const WIDTH=canvas.width/this.SCALE, HEIGHT=canvas.height/this.SCALE, HALF_W=WIDTH/2;
                    uiLayer.innerHTML = `<div class="ui-label-top" style="color:#000; text-shadow:none;"><span>Scenario A: Chaos</span><span>Scenario B: Order</span></div>`;
                    this.entities.push(this.createWalker(HALF_W/2-2, HEIGHT/2, 'random'));
                    this.entities.push(this.createWalker(HALF_W/2+2, HEIGHT/2, 'random'));
                    this.entities.push(this.createWalker(HALF_W+HALF_W/2, HEIGHT/2, 'directed'));
                    for(let i=0; i<50; i++) this.snow.push({x:Math.random()*WIDTH, y:Math.random()*HEIGHT, speed:0.2+Math.random()*0.5});
                },
                createWalker: function(x, y, type) {
                    return { x,y,type, update: function(fc, dir, w, h, hw) {
                        if(fc%10!==0)return; let dx=0,dy=0,s=2;
                        if(this.type==='random'){const r=Math.floor(Math.random()*4); if(r===0)dy=-s;if(r===1)dx=s;if(r===2)dy=s;if(r===3)dx=-s;}
                        else{if(dir===0)dy=-s;if(dir===1)dx=s;if(dir===2)dy=s;if(dir===3)dx=-s;}
                        this.x+=dx; this.y+=dy;
                        if(this.type==='random'){this.x=Math.max(2,Math.min(hw-2,this.x));}else{this.x=Math.max(hw+2,Math.min(w-2,this.x));}
                        this.y=Math.max(2,Math.min(h-2,this.y));
                    }};
                },
                update: function() {
                    const W=canvas.width/this.SCALE, H=canvas.height/this.SCALE, HW=W/2;
                    this.frameCount++;
                    if(this.frameCount-this.lastShoutTime>60){this.towerDirection=Math.floor(Math.random()*4);this.lastShoutTime=this.frameCount;}
                    this.entities.forEach(e=>e.update(this.frameCount,this.towerDirection,W,H,HW));
                    this.snow.forEach(p=>{p.y+=p.speed;p.x+=Math.sin(this.frameCount*0.05)*0.5;if(p.y>H)p.y=0;if(p.x>W)p.x=0;});
                },
                draw: function() {
                    const W=canvas.width/this.SCALE, H=canvas.height/this.SCALE, HW=W/2;
                    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.scale(this.SCALE,this.SCALE);
                    ctx.fillStyle='#F0E68C'; ctx.fillRect(0,0,W,H);
                    const sz=40; ctx.fillStyle='#32CD32'; ctx.fillRect(HW/2-sz/2,H/2-sz/2,sz,sz); ctx.fillRect(HW+HW/2-sz/2,H/2-sz/2,sz,sz);
                    ctx.fillStyle='#000'; ctx.fillRect(HW-1,0,2,H);
                    ctx.fillStyle='#FFF'; this.snow.forEach(p=>ctx.fillRect(Math.floor(p.x),Math.floor(p.y),1,1));
                    const tx=W-20, ty=20;
                    ctx.fillStyle='#8B4513'; ctx.fillRect(tx,ty,8,12); ctx.fillStyle='#5c2e0b'; ctx.fillRect(tx+1,ty+2,1,1); ctx.fillRect(tx+5,ty+6,1,1);
                    ctx.fillStyle='#8B4513'; ctx.fillRect(tx-1,ty,10,2); ctx.fillStyle='#1E90FF'; ctx.fillRect(tx+2,ty-3,4,4); ctx.fillStyle='#FFCCAA'; ctx.fillRect(tx+3,ty-2,2,2);
                    this.drawBubble(tx-14,ty-8,this.towerDirection);
                    ctx.fillStyle='#000'; this.entities.forEach(e=>{ctx.fillRect(e.x,e.y,3,3);ctx.fillRect(e.x+1,e.y-1,1,1);});
                },
                drawBubble: function(x,y,d) {
                    ctx.fillStyle='#FFF';ctx.strokeStyle='#000';ctx.lineWidth=1;ctx.fillRect(x,y,12,11);ctx.strokeRect(x,y,12,11);
                    ctx.fillStyle='#000';const cx=x+6,cy=y+5.5;ctx.beginPath();
                    if(d===0){ctx.moveTo(cx,cy-3);ctx.lineTo(cx-2,cy);ctx.lineTo(cx+2,cy);}else if(d===1){ctx.moveTo(cx+3,cy);ctx.lineTo(cx,cy-2);ctx.lineTo(cx,cy+2);}
                    else if(d===2){ctx.moveTo(cx,cy+3);ctx.lineTo(cx-2,cy);ctx.lineTo(cx+2,cy);}else{ctx.moveTo(cx-3,cy);ctx.lineTo(cx,cy-2);ctx.lineTo(cx,cy+2);}
                    ctx.fill(); ctx.fillStyle='#FFF';ctx.fillRect(x+10,y+8,2,2);ctx.fillRect(x+8,y+10,2,2);
                }
            },

            // --- GAME 2: NUTCRACKER ---
            nutcracker: {
                frameCount: 0, SCALE: 4, angle: 0, soldierAngle: 0, history: [], sweat: [], snow: [],
                init: function() {
                    canvas.height = 320; this.frameCount=0; this.angle=0; this.soldierAngle=0; this.history=[]; this.sweat=[]; this.snow=[];
                    const WIDTH = canvas.width/this.SCALE; const HEIGHT = canvas.height/this.SCALE;
                    uiLayer.innerHTML = `<div class="ui-label-top" style="color:#fbbf24;"><span>Feedback Loop</span><span>Signal Response</span></div><div class="ui-label-bottom"><span>Shared Energy</span><span>Heat &Phi; = Cost</span></div>`;
                    for(let i=0;i<40;i++) this.snow.push({x:Math.random()*WIDTH,y:Math.random()*HEIGHT,speed:0.1+Math.random()*0.4});
                },
                update: function() {
                    this.frameCount++; const WIDTH=canvas.width/this.SCALE; const HEIGHT=canvas.height/this.SCALE;
                    this.angle+=0.05;
                    const r=20, c2X=(WIDTH/2)+(WIDTH/4), c2Y=HEIGHT/2+10;
                    this.soldierAngle+=0.04;
                    const sX=c2X+Math.cos(this.soldierAngle)*(r*0.8), sY=c2Y+Math.sin(this.soldierAngle)*(r*0.4)+5;
                    this.history.push({x:sX,y:sY,f:Math.sin(this.soldierAngle)>0});
                    if(this.history.length>26) this.history.shift();
                    if(this.history.length>=25 && this.frameCount%10===0) {
                        const h=this.history[0]; this.sweat.push({x:h.x,y:h.y-8,vx:(Math.random()-0.5),vy:-0.5-Math.random()});
                    }
                    for(let i=this.sweat.length-1;i>=0;i--){let p=this.sweat[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; if(p.y>HEIGHT)this.sweat.splice(i,1);}
                    this.snow.forEach(p=>{p.y+=p.speed;p.x+=Math.sin(this.frameCount*0.02)*0.2;if(p.y>HEIGHT)p.y=0;if(p.x>WIDTH)p.x=0;});
                },
                draw: function() {
                    const WIDTH=canvas.width/this.SCALE, HEIGHT=canvas.height/this.SCALE, HW=WIDTH/2, CX=HW/2, CY=HEIGHT/2+10, R=20;
                    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.scale(this.SCALE,this.SCALE);
                    ctx.fillStyle='#1e293b'; ctx.fillRect(0,0,HW,HEIGHT);
                    ctx.fillStyle='#e0f2fe'; ctx.beginPath(); ctx.ellipse(CX,CY+8,28,13,0,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle='#0f172a'; ctx.fillRect(HW,0,HW,HEIGHT);
                    ctx.fillStyle='#e2e8f0'; ctx.beginPath(); ctx.ellipse(CX+HW,CY+8,28,13,0,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle='#000'; ctx.fillRect(HW-1,0,2,HEIGHT);
                    const d1X=CX+Math.cos(this.angle)*(R*0.7), d1Y=CY+Math.sin(this.angle)*(R*0.35)+5;
                    const d2X=CX+Math.cos(this.angle+Math.PI)*(R*0.7), d2Y=CY+Math.sin(this.angle+Math.PI)*(R*0.35)+5;
                    const dd=(x,y,f)=>{
                        ctx.fillStyle='#f472b6';ctx.fillRect(x-3,y+2,7,3);ctx.fillStyle='#fdf2f8';ctx.fillRect(x,y-1,1,3);ctx.fillStyle='#ffe4e6';ctx.fillRect(x,y-3,2,2);
                        if(Math.floor(f/10)%2===0){ctx.fillRect(x,y+5,1,3);}else{ctx.fillRect(x-1,y+4,1,2);ctx.fillRect(x+1,y+5,1,3);}
                    };
                    if(Math.sin(this.angle)<0){dd(d1X,d1Y,this.frameCount);dd(d2X,d2Y,this.frameCount);}else{dd(d2X,d2Y,this.frameCount);dd(d1X,d1Y,this.frameCount);}
                    ctx.strokeStyle='#fbcfe8';ctx.beginPath();ctx.moveTo(d1X+1,d1Y+2);ctx.lineTo(d2X+1,d2Y+2);ctx.stroke();
                    const c2X=CX+HW, c2Y=CY, sX=c2X+Math.cos(this.soldierAngle)*(R*0.8), sY=c2Y+Math.sin(this.soldierAngle)*(R*0.4)+5;
                    const ents=[{t:'s',x:sX,y:sY,f:Math.sin(this.soldierAngle)>0}];
                    if(this.history.length>=25){const h=this.history[0]; ents.push({t:'m',x:h.x,y:h.y,f:h.f});}
                    ents.sort((a,b)=>a.y-b.y);
                    ents.forEach(e=>{
                        ctx.save();ctx.translate(e.x,e.y);if(e.f)ctx.scale(-1,1);
                        const m=Math.floor(this.frameCount/8)%2, ox=-2, oy=0;
                        if(e.t==='s'){
                            ctx.fillStyle='#000';ctx.fillRect(ox,oy-6,4,5);ctx.fillStyle='#fbbf24';ctx.fillRect(ox+1,oy-4,2,1);
                            ctx.fillStyle='#fca5a5';ctx.fillRect(ox,oy-1,4,3);ctx.fillStyle='#000';ctx.fillRect(ox+1,oy+1,2,1);
                            ctx.fillStyle='#ef4444';ctx.fillRect(ox-1,oy+2,6,6);
                            ctx.fillStyle='#fff';ctx.fillRect(ox,oy+2,1,1);ctx.fillRect(ox+1,oy+3,1,1);ctx.fillRect(ox+2,oy+4,1,1);ctx.fillRect(ox+3,oy+5,1,1);
                            ctx.fillStyle='#1e293b';if(m===0){ctx.fillRect(ox,oy+8,1,4);ctx.fillRect(ox+3,oy+8,1,4);}else{ctx.fillRect(ox,oy+7,1,3);ctx.fillRect(ox+3,oy+8,1,4);}
                        }else{
                            ctx.fillStyle='#000';ctx.fillRect(ox,oy-5,5,2);ctx.fillStyle='#fff';ctx.fillRect(ox+1,oy-3,3,3);
                            ctx.fillStyle='#fff';ctx.fillRect(ox,oy,5,6);ctx.fillStyle='#334155';ctx.fillRect(ox,oy+1,5,1);ctx.fillRect(ox,oy+3,5,1);ctx.fillRect(ox,oy+5,5,1);
                            ctx.fillStyle='#000';if(m===0){ctx.fillRect(ox+1,oy+6,1,4);ctx.fillRect(ox+3,oy+6,1,4);}else{ctx.fillRect(ox+1,oy+5,1,3);ctx.fillRect(ox+3,oy+6,1,4);}
                        }
                        ctx.restore();
                    });
                    ctx.fillStyle='#0ea5e9'; this.sweat.forEach(p=>ctx.fillRect(p.x,p.y,1,1));
                    ctx.fillStyle='#fff'; this.snow.forEach(p=>ctx.fillRect(Math.floor(p.x),Math.floor(p.y),1,1));
                }
            },

            // --- GAME 3: SHUTTER ---
            shutter: {
                frameCount: 0, SCALE: 4, tau: 0.5,
                init: function() {
                    canvas.height = 320; this.frameCount=0; this.tau=0.5;
                    uiLayer.innerHTML = `<div class="ui-label-top" style="color:#ff0055; text-align:left; padding-left:10px;">TARGET: SPEEDING CAR</div><div id="status-label" style="position:absolute; bottom:20px; width:100%; text-align:center; color:#fff; font-size:12px; text-shadow:2px 2px #000;">WAITING...</div>`;
                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `<div class="control-group"><div style="display:flex; justify-content:space-between; width:100%; color:#94a3b8; font-size:10px; margin-bottom:5px;"><span>Noise</span><span>Peak</span><span>Loss</span></div><input type="range" id="shutterSlider" min="0" max="100" value="50"><div style="font-size:10px; color:#666; margin-top:5px; text-align:center;">ADJUST OBSERVATION TIME (&tau;)</div></div>`;
                    document.getElementById('shutterSlider').addEventListener('input', e=>this.tau=parseInt(e.target.value)/100);
                },
                update: function() {
                    this.frameCount++; const lbl = document.getElementById('status-label');
                    if(this.tau<0.2){lbl.innerText="NOISE DOMINANCE (Zoomed, High Entropy)";lbl.style.color="#ef4444";}
                    else if(this.tau>0.8){lbl.innerText="MEMORY LOSS (Signal Departed)";lbl.style.color="#64748b";}
                    else{lbl.innerText="CAUSAL PEAK (Signal Captured)";lbl.style.color="#32CD32";}
                },
                draw: function() {
                    const WIDTH=canvas.width/this.SCALE, HEIGHT=canvas.height/this.SCALE;
                    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.scale(this.SCALE,this.SCALE);
                    ctx.fillStyle='#111'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,WIDTH,HEIGHT/2); ctx.fillStyle='#333'; ctx.fillRect(0,HEIGHT/2,WIDTH,HEIGHT/2);
                    ctx.fillStyle='#555'; const sp=(this.frameCount*4)%40; for(let i=-40;i<WIDTH;i+=40)ctx.fillRect(i-sp,HEIGHT/2+20,20,2);
                    const cx=(WIDTH/2)-15, cy=(HEIGHT/2)+10; let z=1, b=0, o=1;
                    if(this.tau<0.5){z=1+(1-(this.tau*2))*11;}else{const f=(this.tau-0.5)*2; o=1-f; b=f*5;}
                    ctx.save();
                    if(z>1){ctx.translate(cx+10,cy+10);ctx.scale(z,z);ctx.translate(-(cx+10),-(cy+10));}
                    const l=1+Math.floor(b*10), st=b*2;
                    for(let i=0;i<l;i++){
                        ctx.globalAlpha=o*(1-(i/l)); const dx=cx-(i*st);
                        ctx.fillStyle='#ef4444';ctx.fillRect(dx,cy,30,10);ctx.fillStyle='#7f1d1d';ctx.fillRect(dx+5,cy-6,18,6);
                        ctx.fillStyle='#93c5fd';ctx.fillRect(dx+16,cy-5,6,4);ctx.fillStyle='#fbbf24';ctx.fillRect(dx,cy+4,30,2);
                        ctx.fillStyle='#111';ctx.fillRect(dx+4,cy+8,6,6);ctx.fillRect(dx+20,cy+8,6,6);
                    }
                    ctx.restore();
                    ctx.setTransform(1,0,0,1,0,0);
                    if(this.tau<0.5){
                        const a=(0.5-this.tau)*0.6, id=ctx.getImageData(0,0,canvas.width,canvas.height), d=id.data;
                        for(let i=0;i<d.length;i+=4){if(Math.random()<a){const v=Math.random()*255;d[i]=v;d[i+1]=v;d[i+2]=v;}}
                        ctx.putImageData(id,0,0);
                    }
                }
            },

            // --- GAME 4: THE WANDERER ---
            wanderer: {
                frameCount:0, SCALE:2, ropeLen:40, wSpeed:2, 
                wanderer:{x:0,y:0,a:0,ta:0,t:0}, sled:{x:0,y:0,a:0}, 
                particles:[], totalHeat:0, 
                history: [], path: [], isReversing: false,

                init: function() {
                    canvas.height=360; this.frameCount=0; this.totalHeat=0; this.particles=[]; this.ropeLen=40; this.wSpeed=2;
                    this.history = []; this.path = []; this.isReversing = false;
                    const W=canvas.width, H=canvas.height;
                    this.wanderer={x:W/2,y:H/2,a:0,ta:0,t:0}; this.sled={x:W/2,y:H/2+40,a:0};
                    uiLayer.innerHTML=`<div class="ui-label-top" style="color:#1e3a8a;"><span>Signal (x)</span><span>Response (y)</span></div><div class="ui-label-bottom"><span id="wand-math">Heat &Phi; &ge; Info T</span></div>`;
                    controlsArea.style.display='flex';
                    controlsArea.innerHTML=`
                        <div class="control-group"><label style="color:#94a3b8; font-size:10px;">Rope Length</label><input type="range" id="ropeSlider" min="10" max="100" value="40"></div>
                        <div class="control-group"><label style="color:#94a3b8; font-size:10px;">Wanderer Speed</label><input type="range" id="speedSlider" min="1" max="10" value="3"></div>
                        <button id="rev-btn" class="rev-btn" onmousedown="games.wanderer.setReverse(true)" onmouseup="games.wanderer.setReverse(false)" ontouchstart="games.wanderer.setReverse(true)" ontouchend="games.wanderer.setReverse(false)">HOLD TO REVERSE TIME</button>
                    `;
                    document.getElementById('ropeSlider').addEventListener('input',e=>this.ropeLen=parseInt(e.target.value));
                    document.getElementById('speedSlider').addEventListener('input',e=>this.wSpeed=parseInt(e.target.value));
                },
                setReverse: function(isRev) {
                    this.isReversing = isRev;
                    const btn = document.getElementById('rev-btn');
                    if(btn) { if(isRev) btn.classList.add('rev-active'); else btn.classList.remove('rev-active'); }
                },
                update: function() {
                    const W=canvas.width, H=canvas.height;
                    if (this.isReversing) {
                        if (this.history.length > 0) {
                            const state = this.history.pop();
                            this.wanderer.x = state.wx; this.wanderer.y = state.wy; this.wanderer.a = state.wa;
                            this.sled.x = state.sx; this.sled.y = state.sy; this.sled.a = state.sa;
                            this.totalHeat = state.heat;
                            this.frameCount--;
                            if (this.path.length > 0 && this.path[this.path.length-1].f >= this.frameCount) this.path.pop();
                        }
                    } else {
                        this.frameCount++;
                        if(this.frameCount>this.wanderer.t){this.wanderer.ta=Math.random()*Math.PI*2;this.wanderer.t=this.frameCount+30+Math.random()*60;}
                        this.wanderer.a+=(this.wanderer.ta-this.wanderer.a)*0.05;
                        this.wanderer.x+=Math.cos(this.wanderer.a)*this.wSpeed; this.wanderer.y+=Math.sin(this.wanderer.a)*this.wSpeed;
                        if(this.wanderer.x<20||this.wanderer.x>W-20){this.wanderer.a=Math.PI-this.wanderer.a;this.wanderer.x=Math.max(20,Math.min(W-20,this.wanderer.x));}
                        if(this.wanderer.y<20||this.wanderer.y>H-20){this.wanderer.a=-this.wanderer.a;this.wanderer.y=Math.max(20,Math.min(H-20,this.wanderer.y));}
                        const dx=this.wanderer.x-this.sled.x, dy=this.wanderer.y-this.sled.y, d=Math.sqrt(dx*dx+dy*dy);
                        let hg=0;
                        if(d>this.ropeLen){
                            const a=Math.atan2(dy,dx), tx=this.wanderer.x-Math.cos(a)*this.ropeLen, ty=this.wanderer.y-Math.sin(a)*this.ropeLen;
                            const mx=(tx-this.sled.x)*0.1, my=(ty-this.sled.y)*0.1;
                            this.sled.x+=mx; this.sled.y+=my; this.sled.a=Math.atan2(my,mx);
                            this.path.push({x:this.sled.x, y:this.sled.y, f:this.frameCount});
                            const md=Math.sqrt(mx*mx+my*my); hg=md*2;
                            if(md>0.5) for(let i=0;i<Math.floor(md);i++) this.particles.push({x:this.sled.x,y:this.sled.y,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,life:1});
                        }
                        this.totalHeat+=hg;
                        this.history.push({wx:this.wanderer.x, wy:this.wanderer.y, wa:this.wanderer.a, sx:this.sled.x, sy:this.sled.y, sa:this.sled.a, heat:this.totalHeat});
                        if(this.history.length > 1000) { this.history.shift(); this.path.shift(); }
                    }
                    document.getElementById('wand-math').innerText=`Entropy Generated (\u03A6): ${Math.floor(this.totalHeat)}`;
                    for(let i=this.particles.length-1;i>=0;i--){let p=this.particles[i];p.x+=p.vx;p.y+=p.vy;p.life-=0.05;if(p.life<=0)this.particles.splice(i,1);}
                },
                draw: function() {
                    ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#f0f9ff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                    if (this.path.length > 1) {
                        ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=6; ctx.lineCap='round'; ctx.lineJoin='round';
                        ctx.beginPath(); ctx.moveTo(this.path[0].x, this.path[0].y);
                        for(let i=1; i<this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y);
                        ctx.stroke();
                    }
                    ctx.strokeStyle='#0f172a';ctx.lineWidth=2;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(this.wanderer.x,this.wanderer.y);ctx.lineTo(this.sled.x,this.sled.y);ctx.stroke();ctx.setLineDash([]);
                    ctx.save();ctx.translate(this.sled.x,this.sled.y);ctx.rotate(this.sled.a);ctx.fillStyle='#0284c7';ctx.fillRect(-10,-5,20,10);ctx.fillStyle='#0c4a6e';ctx.fillRect(-10,-8,20,2);ctx.fillRect(-10,6,20,2);ctx.restore();
                    ctx.save();ctx.translate(this.wanderer.x,this.wanderer.y);const b=Math.sin(this.frameCount*0.2)*2;
                    ctx.fillStyle='rgba(0,0,0,0.2)';ctx.beginPath();ctx.ellipse(0,10,8,4,0,0,Math.PI*2);ctx.fill();
                    ctx.fillStyle='#dc2626';ctx.fillRect(-6,-10+b,12,14);ctx.fillStyle='#fecaca';ctx.fillRect(-4,-18+b,8,8);ctx.fillStyle='#991b1b';ctx.fillRect(-5,-20+b,10,4);ctx.restore();
                    if (!this.isReversing) { ctx.fillStyle='#f59e0b';this.particles.forEach(p=>{ctx.globalAlpha=p.life;ctx.fillRect(p.x,p.y,2,2);});ctx.globalAlpha=1; }
                }
            },

            // --- GAME 5: BLIND RUDOLPH & GUY (Overhauled) ---
            chimney: {
                frameCount:0, SCALE:2, 
                wanderer:{x:320,y:100,a:0,ta:0,t:0}, sled:{x:320,y:250,a:0},
                particles:[], totalHeat:0, ropeLen:100, wandererAmp:1,
                history: [], path: [], isReversing: false,

                init: function() {
                    canvas.height=360; this.frameCount=0; this.totalHeat=0; this.particles=[]; 
                    this.history = []; this.path = []; this.isReversing = false;
                    const W=canvas.width, H=canvas.height;
                    
                    this.wanderer={x:W/2, y:80, a:0, ta:0, t:0}; 
                    this.sled={x:W/2, y:200, a:0};
                    this.ropeLen = 100;

                    uiLayer.innerHTML=`<div class="ui-label-top" style="color:#4ade80;"><span>Blind Rudolph (Free)</span><span>The Cage</span><span>Guy (Trapped)</span></div><div class="ui-label-bottom"><span id="chimney-status">Status: EQUILIBRIUM</span></div>`;
                    
                    controlsArea.style.display='flex';
                    controlsArea.innerHTML=`
                        <div class="control-group" style="width:100%"><label style="color:#94a3b8; font-size:10px;">Rope on a Spool (&beta;)</label><input type="range" id="ropeSlider" min="20" max="250" value="100"></div>
                        <button id="rev-btn" class="rev-btn" onmousedown="games.chimney.setReverse(true)" onmouseup="games.chimney.setReverse(false)" ontouchstart="games.chimney.setReverse(true)" ontouchend="games.chimney.setReverse(false)">HOLD TO REVERSE TIME</button>
                    `;
                    document.getElementById('ropeSlider').addEventListener('input',e=>this.ropeLen=parseInt(e.target.value));
                },

                setReverse: function(isRev) {
                    this.isReversing = isRev;
                    const btn = document.getElementById('rev-btn');
                    if(btn) { if(isRev) btn.classList.add('rev-active'); else btn.classList.remove('rev-active'); }
                },

                update: function() {
                    const W=canvas.width, H=canvas.height;
                    
                    if (this.isReversing) {
                        if (this.history.length > 0) {
                            const state = this.history.pop();
                            this.wanderer.x = state.wx; this.wanderer.y = state.wy; this.wanderer.a = state.wa;
                            this.sled.x = state.sx; this.sled.y = state.sy; this.sled.a = state.sa;
                            this.totalHeat = state.heat;
                            this.frameCount--;
                            if (this.path.length > 0 && this.path[this.path.length-1].f >= this.frameCount) this.path.pop();
                        }
                    } else {
                        this.frameCount++;
                        
                        // 1. Rudolph 2D Random Walk (Signal)
                        if(this.frameCount > this.wanderer.t){
                            this.wanderer.ta = Math.random()*Math.PI*2;
                            this.wanderer.t = this.frameCount + 30 + Math.random()*60;
                        }
                        this.wanderer.a += (this.wanderer.ta - this.wanderer.a)*0.05;
                        this.wanderer.x += Math.cos(this.wanderer.a)*1.5; 
                        this.wanderer.y += Math.sin(this.wanderer.a)*1.5;

                        // Bounds for Rudolph (Free, Top/Mid)
                        this.wanderer.x = Math.max(20, Math.min(W-20, this.wanderer.x));
                        this.wanderer.y = Math.max(20, Math.min(H-20, this.wanderer.y));

                        // 2. Rope Physics (Response Follows Signal)
                        const dx = this.wanderer.x - this.sled.x;
                        const dy = this.wanderer.y - this.sled.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const ps = {x:this.sled.x, y:this.sled.y};

                        // Logic: If rope is tight, pull Guy
                        if (dist > this.ropeLen) {
                            const angle = Math.atan2(dy, dx);
                            const targetX = this.wanderer.x - Math.cos(angle)*this.ropeLen;
                            const targetY = this.wanderer.y - Math.sin(angle)*this.ropeLen;
                            
                            // Slide towards target
                            this.sled.x += (targetX - this.sled.x) * 0.2;
                            this.sled.y += (targetY - this.sled.y) * 0.2;
                            this.sled.a = Math.atan2(dy, dx); // Face Rudolph
                        }

                        // 3. CAGE Constraints (The Trap)
                        // Centered cage
                        const CW = 120, CH = 120;
                        const CL = W/2 - CW/2, CR = W/2 + CW/2, CT = H/2 - CH/2, CB = H/2 + CH/2;
                        
                        let hit = false;
                        if(this.sled.x < CL) { this.sled.x = CL; hit=true; }
                        if(this.sled.x > CR) { this.sled.x = CR; hit=true; }
                        if(this.sled.y < CT) { this.sled.y = CT; hit=true; }
                        if(this.sled.y > CB) { this.sled.y = CB; hit=true; }

                        // 4. Heat & Tracks
                        const moveDist = Math.sqrt(Math.pow(this.sled.x-ps.x,2) + Math.pow(this.sled.y-ps.y,2));
                        
                        if (moveDist > 0.1) {
                            this.path.push({x:this.sled.x, y:this.sled.y, f:this.frameCount});
                            if (this.path.length > 500) this.path.shift();

                            // Heat
                            const hf = moveDist * 5;
                            for(let i=0; i<Math.floor(hf); i++) {
                                this.particles.push({
                                    x:this.sled.x, y:this.sled.y, 
                                    vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, 
                                    life:1, color:'#fef3c7'
                                });
                            }
                        }

                        // UI Status
                        const sl=document.getElementById('chimney-status');
                        if(hit){sl.innerText="Status: PINNED (Blindness)";sl.style.color="#ef4444";}
                        else if(moveDist>0.1){sl.innerText="Status: TRACKING";sl.style.color="#fbbf24";}
                        else{sl.innerText="Status: SLACK (No Info)";sl.style.color="#64748b";}

                        // Save History
                        this.history.push({
                            wx:this.wanderer.x, wy:this.wanderer.y, wa:this.wanderer.a,
                            sx:this.sled.x, sy:this.sled.y, sa:this.sled.a,
                            heat:0 // Simplified
                        });
                        if(this.history.length>1000) { this.history.shift(); this.path.shift(); }
                    }

                    // Particles always update forward
                    for(let i=this.particles.length-1;i>=0;i--){let p=this.particles[i];p.x+=p.vx;p.y+=p.vy;p.life-=0.05;if(p.life<=0)this.particles.splice(i,1);}
                },

                draw: function() {
                    const W=canvas.width, H=canvas.height;
                    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H);
                    
                    // Background
                    ctx.fillStyle='#0f172a';ctx.fillRect(0,0,W,H); 

                    // Cage Floor
                    const CW=120, CH=120;
                    const CL=W/2-CW/2, CR=W/2+CW/2, CT=H/2-CH/2, CB=H/2+CH/2;
                    ctx.fillStyle='#1e293b'; ctx.fillRect(CL, CT, CW, CH);

                    // Tracks (Inside Cage mostly)
                    if (this.path.length > 1) {
                        ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=4; ctx.lineCap='round'; ctx.lineJoin='round';
                        ctx.beginPath();
                        ctx.moveTo(this.path[0].x, this.path[0].y);
                        for(let i=1; i<this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y);
                        ctx.stroke();
                    }

                    // Cage Bars
                    ctx.strokeStyle='#22c55e'; ctx.lineWidth=4;
                    ctx.strokeRect(CL, CT, CW, CH);

                    // Rope
                    ctx.beginPath();
                    ctx.strokeStyle='#94a3b8';ctx.lineWidth=2;
                    // Slack vs Tight visual
                    const dx = this.wanderer.x - this.sled.x;
                    const dy = this.wanderer.y - this.sled.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < this.ropeLen - 10) {
                        // Draw slack curve (bezier)
                        ctx.moveTo(this.wanderer.x, this.wanderer.y);
                        ctx.quadraticCurveTo(this.wanderer.x, this.sled.y, this.sled.x, this.sled.y);
                    } else {
                        // Tight
                        ctx.moveTo(this.wanderer.x, this.wanderer.y);
                        ctx.lineTo(this.sled.x, this.sled.y);
                    }
                    ctx.stroke();

                    // Rudolph
                    const rx=this.wanderer.x, ry=this.wanderer.y;
                    ctx.save(); ctx.translate(rx,ry);
                    if (Math.cos(this.wanderer.a) < 0) ctx.scale(-1,1); // Face direction
                    ctx.fillStyle='#92400e';ctx.fillRect(-10,-6,20,12);ctx.fillStyle='#b45309';ctx.fillRect(8,-10,10,10);
                    ctx.fillStyle='#ef4444';ctx.shadowColor='#ef4444';ctx.shadowBlur=10;ctx.beginPath();ctx.arc(18,-5,3,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;
                    ctx.fillStyle='#fcd34d';ctx.fillRect(10,-14,2,4);ctx.fillRect(14,-14,2,4);
                    const l=Math.sin(this.frameCount*0.5)*3;ctx.fillStyle='#92400e';ctx.fillRect(-8,6+l,4,6);ctx.fillRect(4,6-l,4,6);
                    ctx.restore(); 

                    // Guy (The Follower - Blue Reindeer)
                    const gx=this.sled.x, gy=this.sled.y;
                    ctx.save(); ctx.translate(gx,gy);
                    // if (Math.cos(this.sled.a) < 0) ctx.scale(-1,1); // Face direction
                    ctx.fillStyle='#3b82f6';ctx.fillRect(-10,-6,20,12); // Blue Body
                    ctx.fillStyle='#2563eb';ctx.fillRect(8,-10,10,10); // Blue Head
                    ctx.fillStyle='#60a5fa';ctx.fillRect(10,-14,2,4);ctx.fillRect(14,-14,2,4); // Antlers
                    ctx.fillStyle='#1d4ed8';ctx.fillRect(-8,6,4,6);ctx.fillRect(4,6,4,6); // Legs
                    ctx.restore();

                    if (!this.isReversing) { ctx.fillStyle='#f59e0b';this.particles.forEach(p=>{ctx.globalAlpha=p.life;ctx.fillRect(p.x,p.y,3,3);});ctx.globalAlpha=1; }
                }
            },

            // --- GAME 6: SIGNAL RUNNER (Receptor Dynamics) ---
            signalRunner: {
                frameCount: 0,
                SCALE: 2,
                ligand: [], receptor: [], switchCountWindow: [],
                beta: 0.15, tau: 20, ligandMean: 0.5,
                metrics: { dissipation:0, information:0, receptorState:0 },
                numReceptors: 100, historyLimit: 600,

                init: function() {
                    canvas.height = 300;
                    this.frameCount = 0;
                    this.ligand = new Array(this.historyLimit).fill(0.5);
                    this.receptor = new Array(this.historyLimit).fill(50);
                    this.switchCountWindow = new Array(60).fill(0);
                    this.beta = 0.15;
                    this.tau = 20;
                    this.ligandMean = 0.5;
                    this.metrics = { dissipation:0, information:0, receptorState:50 };

                    uiLayer.innerHTML = `
                        <div style="position:absolute; top:10px; left:10px; font-size:10px; color:#ef4444;">[L] Ligand Input</div>
                        <div style="position:absolute; top:25px; left:10px; font-size:10px; color:#3b82f6;">Receptor Output [%]</div>
                        <div class="hud-bar" style="right:10px; height:120px; border-color:#334155;">
                            <div style="position:absolute; bottom:0; width:100%; background:#ef4444; height:${this.metrics.dissipation*10}%" id="dissip-bar"></div>
                        </div>
                        <div style="position:absolute; top:20px; right:35px; text-align:right;">
                            <div style="font-size:10px; color:#ef4444;">DISSIPATION (&Phi;) <span id="val-phi">0.00</span></div>
                            <div style="font-size:10px; color:#22c55e; margin-top:5px;">INFORMATION (T) <span id="val-t">0.00</span></div>
                            <div style="font-size:10px; color:#3b82f6; margin-top:5px;">OCCUPANCY <span id="val-occ">50%</span></div>
                        </div>
                    `;

                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `
                        <div class="control-group"><label style="color:#ef4444; font-size:10px;">[L] Mean Ligand</label><input type="range" id="ligandSlider" min="1" max="30" value="5"></div>
                        <div class="control-group"><label style="color:#3b82f6; font-size:10px;">&beta; (Relaxation/Cost)</label><input type="range" id="betaSlider" min="1" max="50" value="15"></div>
                        <div class="control-group" style="width:100%"><label style="color:#fbbf24; font-size:10px;">&tau; (Time Lag)</label><input type="range" id="tauSlider" min="0" max="200" value="20"></div>
                    `;

                    document.getElementById('ligandSlider').addEventListener('input', e => this.ligandMean = parseInt(e.target.value)/10);
                    document.getElementById('betaSlider').addEventListener('input', e => this.beta = parseInt(e.target.value)/100);
                    document.getElementById('tauSlider').addEventListener('input', e => this.tau = parseInt(e.target.value));
                },

                update: function() {
                    // Physics Logic
                    const theta = 0.05, sigma = 0.1;
                    const prevL = this.ligand[this.ligand.length-1];
                    const noise = (Math.random()-0.5)*2;
                    let newL = prevL + theta*(this.ligandMean - prevL) + sigma*noise;
                    newL = Math.max(0.0, newL);

                    const prevR = this.receptor[this.receptor.length-1];
                    const k_on = 0.3;
                    let binds=0, unbinds=0;

                    // Stochastic update
                    for(let i=0; i<prevR; i++) if(Math.random() < this.beta) unbinds++;
                    const free = this.numReceptors - prevR;
                    const p_bind = Math.min(1, k_on * newL);
                    for(let i=0; i<free; i++) if(Math.random() < p_bind) binds++;

                    const newR = prevR + binds - unbinds;

                    // Buffers
                    this.ligand.push(newL); this.ligand.shift();
                    this.receptor.push(newR); this.receptor.shift();

                    // Metrics
                    const totalEvents = binds + unbinds;
                    this.switchCountWindow.push(totalEvents);
                    this.switchCountWindow.shift();
                    const eventRate = this.switchCountWindow.reduce((a,b)=>a+b,0) / this.switchCountWindow.length;
                    
                    const phi = (eventRate / this.numReceptors) * (1 + this.beta*10) * 10;
                    
                    // Correlation (T)
                    const corr = this.calcCorr(this.receptor, this.ligand, this.tau);
                    const t = Math.max(0, corr*corr);

                    this.metrics = { dissipation: phi, information: t, receptorState: newR };
                    this.frameCount++;

                    if(this.frameCount%5===0) {
                        document.getElementById('val-phi').innerText = phi.toFixed(2);
                        document.getElementById('val-t').innerText = t.toFixed(2);
                        document.getElementById('val-occ').innerText = newR + "%";
                        document.getElementById('dissip-bar').style.height = Math.min(100, phi*10) + "%";
                    }
                },

                calcCorr: function(yArr, xArr, lag) {
                    const n = yArr.length;
                    if (n < lag + 10) return 0;
                    let sx=0, sy=0, sxy=0, sx2=0, sy2=0;
                    const count = n-lag;
                    for(let i=lag; i<n; i++) {
                        const y = yArr[i];
                        const x = xArr[i-lag];
                        sx+=x; sy+=y; sxy+=x*y; sx2+=x*x; sy2+=y*y;
                    }
                    const num = (count*sxy) - (sx*sy);
                    const den = Math.sqrt((count*sx2 - sx*sx) * (count*sy2 - sy*sy));
                    return den===0 ? 0 : num/den;
                },

                draw: function() {
                    const W = canvas.width, H = canvas.height;
                    const groundY = H - 20;
                    const ceilingY = H * 0.4;
                    const graphH = groundY - ceilingY;

                    ctx.clearRect(0, 0, W, H);

                    // Saturation Line
                    ctx.strokeStyle = '#334155'; ctx.setLineDash([4,4]); ctx.lineWidth=1;
                    ctx.beginPath(); ctx.moveTo(0, ceilingY); ctx.lineTo(W, ceilingY); ctx.stroke();
                    ctx.fillStyle='#64748b'; ctx.font='10px monospace'; ctx.fillText('SATURATION', 5, ceilingY-5);
                    ctx.setLineDash([]);

                    // Draw Ligand (Red)
                    ctx.beginPath(); ctx.strokeStyle='#ef4444'; ctx.lineWidth=2;
                    const xStep = W / this.historyLimit;
                    this.ligand.forEach((val, i) => {
                        const x = i * xStep;
                        const y = groundY - (val * graphH);
                        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                    });
                    ctx.stroke();

                    // Draw Receptor (Blue Area)
                    ctx.beginPath(); ctx.fillStyle='rgba(59, 130, 246, 0.4)'; ctx.strokeStyle='#3b82f6';
                    ctx.moveTo(0, groundY);
                    this.receptor.forEach((val, i) => {
                        const x = i * xStep;
                        const y = groundY - ((val/this.numReceptors) * graphH);
                        ctx.lineTo(x,y);
                    });
                    ctx.lineTo(W, groundY); ctx.fill(); ctx.stroke();

                    // Tau Line
                    const pastX = W - (this.tau * xStep);
                    ctx.setLineDash([5,5]); ctx.strokeStyle='#fbbf24'; ctx.beginPath();
                    ctx.moveTo(pastX, 0); ctx.lineTo(pastX, H); ctx.stroke();
                    ctx.fillStyle='#fbbf24'; ctx.fillText(`-${this.tau}`, pastX-20, H-5);
                }
            }
        };

    </script>
</body>
</html>
