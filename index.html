<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>80s Thermodynamics Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050510;
            --text-color: #dbeafe;
            --accent-color: #ff0055;
            --crt-scanline: rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Better for mobile scrolling */
            overflow-x: hidden;
            overflow-y: auto;
            user-select: none;
            padding: 20px 10px;
        }

        /* --- MENU STYLES --- */
        #main-menu {
            text-align: center;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #fbbf24;
            text-shadow: 4px 4px #be123c;
            font-size: clamp(16px, 5vw, 24px); /* Fluid font size */
            margin-bottom: 30px;
            line-height: 1.5;
            padding: 0 10px;
        }

        .menu-btn {
            background: transparent;
            border: 2px solid #334155;
            color: #94a3b8;
            padding: 20px; /* Larger touch target */
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(10px, 3vw, 12px);
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            width: 90%;
            max-width: 380px;
            margin: 0 auto;
        }

        .menu-btn:active, .menu-btn:hover {
            border-color: #38bdf8;
            color: #fff;
            background: rgba(56, 189, 248, 0.1);
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }

        /* --- GAME CONTAINER --- */
        #game-wrapper {
            display: none;
            position: relative;
            border: 8px solid #2a2a3a; /* Thinner border on mobile */
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background: #000;
            margin-top: 10px;
            width: 100%;
            max-width: 640px;
            /* Maintain aspect ratio or adapt to content */
        }

        @media (min-width: 600px) {
            #game-wrapper {
                border-width: 16px;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            }
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: auto; /* Maintains aspect ratio */
        }

        /* --- SHARED UI OVERLAYS --- */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
            animation: flicker 0.15s infinite;
            opacity: 0.5; /* Slightly less intense on mobile */
        }
        
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,50,0.3) 100%);
            pointer-events: none;
            z-index: 51;
        }

        #game-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 52;
        }

        /* Dynamic UI Control Panel (Below Canvas) */
        #controls-area {
            display: none;
            margin-top: 15px;
            width: 100%;
            max-width: 640px;
            background: #111;
            padding: 15px;
            border: 2px solid #333;
            border-radius: 8px;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        /* Description Area */
        #description-area {
            display: none;
            margin-top: 15px;
            width: 100%;
            max-width: 640px;
            background: #0f172a;
            border: 1px solid #1e293b;
            padding: 15px;
            font-family: monospace;
            font-size: 11px; /* Readable on mobile */
            line-height: 1.5;
            color: #94a3b8;
            white-space: pre-wrap;
            border-radius: 4px;
            margin-bottom: 30px;
        }

        #description-area h3 {
            color: #38bdf8;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            margin-top: 0;
            margin-bottom: 10px;
            text-transform: uppercase;
            border-bottom: 1px solid #334155;
            padding-bottom: 8px;
        }

        #description-area strong { color: #e2e8f0; }
        #description-area em { color: #fbbf24; font-style: normal; }
        
        .narrative-text {
            color: #dbeafe;
            margin-bottom: 15px;
            font-style: italic;
            border-left: 3px solid #fbbf24;
            padding-left: 10px;
        }
        
        .variable-text {
            color: #94a3b8;
            font-size: 10px;
        }

        /* Back Button - Responsive Positioning */
        #back-btn {
            background: #be123c;
            border: none;
            color: white;
            padding: 12px 16px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            z-index: 200;
            display: none;
            margin-bottom: 10px; /* Static flow on mobile */
            width: 100%;
            max-width: 640px;
            text-align: center;
            border-radius: 4px;
        }
        
        #back-btn:hover { background: #e11d48; }

        @keyframes flicker {
            0% { opacity: 0.9; }
            50% { opacity: 1.0; }
            100% { opacity: 0.9; }
        }

        /* Helper for injected UI elements */
        .ui-label-top {
            position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-around;
            text-shadow: 2px 2px #000; font-size: clamp(8px, 2.5vw, 12px); text-transform: uppercase;
            padding: 0 5px;
        }
        .ui-label-bottom {
            position: absolute; bottom: 10px; width: 100%; display: flex; justify-content: space-around;
            text-shadow: 2px 2px #000; font-size: clamp(7px, 2.5vw, 10px); color: #94a3b8;
            padding: 0 5px;
        }
        
        /* Range Slider Styling - Touch Friendly */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 10px 0; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; background: #3b82f6;
            cursor: pointer; margin-top: -10px; box-shadow: 0 0 5px #3b82f6; border: 2px solid #fff;
            border-radius: 50%; /* Easier to grab */
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #333; border: 1px solid #555;
        }

        /* Control Group Layout */
        .control-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        
        @media (min-width: 600px) {
            .control-group {
                width: 45%;
                margin-bottom: 0;
            }
        }

    </style>
</head>
<body>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <h1>THERMODYNAMICS<br>ARCADE</h1>
        <button class="menu-btn" onclick="GameManager.load('snowstorm')">1. Chaos vs Order</button>
        <button class="menu-btn" onclick="GameManager.load('nutcracker')">2. Feedback Loops</button>
        <button class="menu-btn" onclick="GameManager.load('shutter')">3. Shutter Speed (Tau)</button>
        <button class="menu-btn" onclick="GameManager.load('wanderer')">4. The Wanderer (Linear)</button>
        <button class="menu-btn" onclick="GameManager.load('chimney')">5. Rudolph's Pipe (Non-Linear)</button>
    </div>

    <!-- Eject Button (Top for mobile ease) -->
    <button id="back-btn" onclick="GameManager.exit()">EJECT CARTRIDGE (BACK TO MENU)</button>

    <!-- GAME AREA -->
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="640" height="320"></canvas>
        <div id="game-ui"></div> <!-- Injected UI Labels -->
        <div class="scanlines"></div>
        <div class="screen-overlay"></div>
    </div>

    <!-- CONTROLS AREA (Below Canvas) -->
    <div id="controls-area"></div>

    <!-- DESCRIPTION AREA (Scientific Log) -->
    <div id="description-area"></div>

    <script>
        // --- GAME ENGINE & STATE MANAGEMENT ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('game-ui');
        const controlsArea = document.getElementById('controls-area');
        const descriptionArea = document.getElementById('description-area');
        
        let animationId = null;

        // --- DESCRIPTIONS (Biophysics Mapping + Strategy Narrative) ---
        const descriptions = {
            snowstorm: `<h3>1. Chaos vs. Order (The Snowstorm)</h3>
<div class="narrative-text">
    "Look closely at the Snowstorm. In Scenario A (Chaos), both walkers are blind. They drift randomly. Their movements are uncorrelated. To a physicist, the 'Mutual Information' between them is zero. They burn energy to move, but they produce nothing but heat.<br><br>
    In Scenario B (Order), we have a Leader (Red) and a Follower (Blue). The Blue dot is fighting the storm to stay close to the Red dot. The Counter-Intuitive Truth: You might assume the 'ordered' walk is efficient. Wrong. To maintain that correlation in a noisy environment, the Follower must constantly correct its path. Every correction requires work. The paper proves that Order is expensive."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Signal):</strong> The "Leader" square in Scenario B. It moves with intent (Directed Walk).<br>
    <strong><em>y</em> (Response):</strong> The "Follower" square in Scenario B. It attempts to copy the Leader's position.<br>
    <strong><em>D</em> (Diffusion/Noise):</strong> The random jitter of the "Snow" particles. This represents the thermal bath that makes tracking difficult.<br>
    <strong>Visual Proof:</strong> In Scenario A, T<sub>y&rarr;x</sub> = 0. In Scenario B, the correlation exists.
</div>`,

            nutcracker: `<h3>2. Feedback Loops (The Nutcracker)</h3>
<div class="narrative-text">
    "Now we break the causal link. On the left, you see a Feedback Loop. Like two dancers, they influence each other. They share the energy load. The system is closed, and the thermodynamics are 'symmetric.'<br><br>
    On the right, we have the Signal-Response Model. The Soldier (<em>x</em>) marches, completely ignoring the Mime (<em>y</em>). The Mime is desperate to copy the Soldier's history. Watch the Mime sweat. That sweat is Mapping Irreversibility (&Phi;). Because the Mime cannot tell the Soldier to slow down (Zero Feedback), he pays the full thermodynamic price for every bit of memory he stores."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong>Topology:</strong><br>
    &bull; <strong>Left Side:</strong> &part;g<sub>x</sub> / &part;y &ne; 0 (Feedback Loop). Energy is shared.<br>
    &bull; <strong>Right Side:</strong> &part;g<sub>x</sub> / &part;y = 0 (Signal-Response). Soldier ignores Mime.<br>
    <strong>&Phi; (Irreversibility):</strong> The Blue Sweat Drops. Represents heat dissipation required by the Second Law.<br>
    <strong>T<sub>y&rarr;x</sub> (Memory):</strong> The Mime’s Pose. His body shape is a "record" of where the Soldier was.
</div>`,

            shutter: `<h3>3. Shutter Speed (The Car Crash)</h3>
<div class="narrative-text">
    "Here is where the math meets reality. How much heat does observation generate? It depends on your shutter speed (&tau;).<br>
    <strong>Noise (&tau; &rarr; 0):</strong> If you sample too fast, you don't see a car; you see vibrating pixels. High energy, zero information.<br>
    <strong>Amnesia (&tau; &rarr; &infin;):</strong> If you wait too long, the car is gone. The correlation decays to zero.<br>
    <strong>The Causal Peak (&tau; &approx; 0.5):</strong> Drag the slider to the middle. See the motion blur? That blur is the Arrow of Time. This is the only window where the system is thermodynamically efficient. Biology lives here."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong>&tau; (Tau):</strong> The Slider Bar. The time gap between snapshots.<br>
    <strong><em>x</em><sub>t</sub> vs <em>x</em><sub>t+&tau;</sub>:</strong> The visual "Motion Blur."<br>
    &bull; Small &tau;: Noise dominance.<br>
    &bull; Large &tau;: Decorrelation.<br>
    &bull; Medium &tau;: The Arrow of Time (Vector formation).
</div>`,

            wanderer: `<h3>4. The Wanderer (Linear Response)</h3>
<div class="narrative-text">
    "Let's translate the math into mechanics. Watch the Red Wanderer. Every step he takes creates a unique path—a History. The Blue Sled tries to follow that path. But the ground is rough. The sled doesn't just glide; it scrapes. That physical Drag—the friction resisting the movement—is the Mapping Irreversibility (&Phi;). It is the heat generated by the act of following.<br><br>
    The Law: You cannot carve the tracks (store the history) without enduring the drag (paying the irreversibility). Memory is friction."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Signal):</strong> The Red Wanderer (Ornstein-Uhlenbeck process).<br>
    <strong><em>y</em> (Response):</strong> The Blue Sled.<br>
    <strong>&beta; (Relaxation Rate):</strong> Rope Stiffness. High &beta; = instant pull (high energy). Low &beta; = lag (low info).<br>
    <strong>&Phi; (Entropy):</strong> The Orange Particles. No movement = No Information = No Heat.<br>
    <strong>Inequality:</strong> &Phi; &ge; T. The particles prove the debt paid to track the signal.
</div>`,

            chimney: `<h3>5. Rudolph's Pipe (Non-Linear Model)</h3>
<div class="narrative-text">
    "Finally, the real biological deal: The Receptor. This isn't a linear rope anymore. It's Rudolph's Pipe.<br>
    <strong>The Walls (Saturation):</strong> If the Present hits the wall, it stops moving. Information flow drops to zero. The cell is blind because it's maxed out.<br>
    <strong>The Sticky Snow (Threshold):</strong> The Present ignores small tugs. It only moves when the Signal (Rudolph) is strong enough to break the 'stickiness.' This filters out noise. Efficiency is about tuning your friction to the environment."
</div>
<hr style="border-color: #334155; margin-bottom: 10px;">
<div class="variable-text">
    <strong><em>x</em> (Signal):</strong> Rudolph (Red Dot). Fluctuating ligand concentration.<br>
    <strong><em>y</em> (Response):</strong> The Gift Box. Receptor state (0 to 1).<br>
    <strong>Walls:</strong> Saturation Limits. Hitting the wall stops Information Flow.<br>
    <strong>Threshold (Stickiness):</strong> Non-Linearity. Simulates activation energy (k<sub>off</sub>). Filters small noise, reacts only to strong signals.
</div>`
        };

        const GameManager = {
            activeGame: null,

            load: function(gameKey) {
                // Hide Menu, Show Game
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game-wrapper').style.display = 'block';
                document.getElementById('back-btn').style.display = 'block'; // Make sure this is block
                
                // Clear previous state
                ctx.clearRect(0,0,canvas.width, canvas.height);
                uiLayer.innerHTML = '';
                controlsArea.innerHTML = '';
                controlsArea.style.display = 'none';

                // Set Description
                if (descriptions[gameKey]) {
                    descriptionArea.innerHTML = descriptions[gameKey];
                    descriptionArea.style.display = 'block';
                }

                // Initialize specific game
                if (games[gameKey]) {
                    this.activeGame = games[gameKey];
                    this.activeGame.init();
                    this.loop();
                }
            },

            exit: function() {
                if (animationId) cancelAnimationFrame(animationId);
                
                // Show Menu, Hide Game
                document.getElementById('main-menu').style.display = 'flex';
                document.getElementById('game-wrapper').style.display = 'none';
                document.getElementById('back-btn').style.display = 'none';
                controlsArea.style.display = 'none';
                descriptionArea.style.display = 'none';
                
                // Cleanup
                this.activeGame = null;
                uiLayer.innerHTML = '';
                controlsArea.innerHTML = '';
                descriptionArea.innerHTML = '';
            },

            loop: function() {
                if (!this.activeGame) return;
                this.activeGame.update();
                this.activeGame.draw();
                animationId = requestAnimationFrame(() => this.loop());
            }
        };

        // --- GAME LIBRARIES ---

        const games = {
            
            // --- GAME 1: SNOWSTORM (Chaos vs Order) ---
            snowstorm: {
                entities: [],
                snow: [],
                frameCount: 0,
                SCALE: 4,

                init: function() {
                    canvas.height = 320;
                    this.frameCount = 0;
                    this.entities = [];
                    this.snow = [];
                    
                    const WIDTH = canvas.width / this.SCALE;
                    const HEIGHT = canvas.height / this.SCALE;
                    const HALF_W = WIDTH / 2;

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #4ade80;">
                            <span>Scenario A: 2 Random Walkers</span>
                            <span>Scenario B: Order (Blue follows Red)</span>
                        </div>
                        <div class="ui-label-bottom" style="text-transform: none; color: #fff; font-size: 9px; text-align:center; width:100%;">
                            <span>The directed walk is faster... but which scenario burns more energy?</span>
                        </div>
                    `;

                    // Init Walkers
                    // Sim 1: 2 Random Walkers (White)
                    this.entities.push({x: (HALF_W/2)-4, y: HEIGHT/2, type: 'white', update: this.randomWalk});
                    this.entities.push({x: (HALF_W/2)+4, y: HEIGHT/2, type: 'white', update: this.randomWalk});
                    
                    // Sim 2: 1 Red (Leader), 1 Blue (Follower)
                    const redX = HALF_W + (HALF_W/2);
                    const redY = HEIGHT/2;
                    // Red Walker (Random Leader)
                    this.entities.push({x: redX, y: redY, type: 'red', update: this.randomWalk});
                    // Blue Walker (Follows Red)
                    this.entities.push({x: redX, y: redY + 10, type: 'blue', update: this.followWalk, targetIndex: 2});

                    // Init Snow (Green Storm)
                    for(let i=0; i<80; i++) {
                        this.snow.push({
                            x: Math.random() * WIDTH,
                            y: Math.random() * HEIGHT,
                            speed: 0.5 + Math.random() * 1.5,
                            opacity: Math.random()
                        });
                    }
                },

                // Behaviors
                randomWalk: function(w, h, hw, entities) {
                    if (games.snowstorm.frameCount % 5 !== 0) return;
                    const step = 2;
                    const r = Math.floor(Math.random() * 4);
                    if (r===0) this.y-=step; if (r===1) this.x+=step; 
                    if (r===2) this.y+=step; if (r===3) this.x-=step;
                    
                    // Bounds (Left or Right side depending on start pos)
                    const isLeft = this.x < hw;
                    const minX = isLeft ? 2 : hw+2;
                    const maxX = isLeft ? hw-2 : w-2;
                    
                    this.x = Math.max(minX, Math.min(maxX, this.x));
                    this.y = Math.max(2, Math.min(h-2, this.y));
                },

                followWalk: function(w, h, hw, entities) {
                    if (games.snowstorm.frameCount % 5 !== 0) return;
                    const target = entities[this.targetIndex];
                    const step = 2;
                    
                    // Simple chase logic
                    if (this.x < target.x) this.x += step;
                    if (this.x > target.x) this.x -= step;
                    if (this.y < target.y) this.y += step;
                    if (this.y > target.y) this.y -= step;
                    
                    // Bounds
                    const minX = hw+2;
                    const maxX = w-2;
                    this.x = Math.max(minX, Math.min(maxX, this.x));
                    this.y = Math.max(2, Math.min(h-2, this.y));
                },

                update: function() {
                    const WIDTH = canvas.width / this.SCALE;
                    const HEIGHT = canvas.height / this.SCALE;
                    const HALF_W = WIDTH / 2;
                    
                    this.frameCount++;

                    this.entities.forEach(e => e.update.call(e, WIDTH, HEIGHT, HALF_W, this.entities));
                    
                    // Snow Logic
                    this.snow.forEach(p => {
                        p.y += p.speed;
                        p.x += Math.sin(this.frameCount * 0.1) * 0.5; // Wind
                        if(p.y > HEIGHT) p.y = 0;
                        if(p.x > WIDTH) p.x = 0;
                    });
                },

                draw: function() {
                    const WIDTH = canvas.width / this.SCALE;
                    const HEIGHT = canvas.height / this.SCALE;
                    const HALF_W = WIDTH / 2;

                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.scale(this.SCALE, this.SCALE);

                    // Backgrounds - The Green Storm
                    ctx.fillStyle = '#022c22'; 
                    ctx.fillRect(0,0,HALF_W, HEIGHT); // Left Storm
                    ctx.fillRect(HALF_W,0,HALF_W, HEIGHT); // Right Storm
                    
                    // Safe Zones
                    ctx.fillStyle = '#1e3a8a';
                    const sz = 40;
                    ctx.fillRect((HALF_W/2)-sz/2, (HEIGHT/2)-sz/2, sz, sz);
                    ctx.fillRect(HALF_W+(HALF_W/2)-sz/2, (HEIGHT/2)-sz/2, sz, sz);
                    
                    ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 1;
                    ctx.strokeRect((HALF_W/2)-sz/2, (HEIGHT/2)-sz/2, sz, sz);
                    ctx.strokeRect(HALF_W+(HALF_W/2)-sz/2, (HEIGHT/2)-sz/2, sz, sz);

                    // Divider
                    ctx.fillStyle = '#000'; ctx.fillRect(HALF_W-1, 0, 2, HEIGHT);

                    // Green Snow Storm Visualization
                    this.snow.forEach(p => {
                        ctx.fillStyle = `rgba(74, 222, 128, ${p.opacity})`; 
                        ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1);
                    });

                    // Walkers
                    this.entities.forEach(e => {
                        if (e.type === 'white') ctx.fillStyle = '#fff';
                        else if (e.type === 'red') ctx.fillStyle = '#ef4444';
                        else if (e.type === 'blue') ctx.fillStyle = '#3b82f6';
                        
                        ctx.fillRect(e.x, e.y, 3, 3);
                        ctx.fillRect(e.x+1, e.y-1, 1, 1);
                        // Small shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.5)';
                        ctx.fillRect(e.x, e.y+3, 3, 1);
                    });
                }
            },


            // --- GAME 2: NUTCRACKER (Feedback) ---
            nutcracker: {
                frameCount: 0,
                SCALE: 4,
                angle: 0, soldierAngle: 0,
                history: [],
                sweat: [], snow: [],

                init: function() {
                    canvas.height = 320;
                    this.frameCount = 0;
                    this.angle = 0;
                    this.soldierAngle = 0;
                    this.history = [];
                    this.sweat = [];
                    this.snow = [];
                    
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #fbbf24;">
                            <span>Feedback Loop</span>
                            <span>Zero Feedback</span>
                        </div>
                        <div class="ui-label-bottom">
                            <span>Shared Energy</span>
                            <span>Heat &Phi; = Cost</span>
                        </div>
                    `;

                    for(let i=0; i<40; i++) {
                        this.snow.push({ x: Math.random()*WIDTH, y: Math.random()*HEIGHT, speed: 0.1+Math.random()*0.4});
                    }
                },

                update: function() {
                    this.frameCount++;
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;
                    
                    // Logic Left (Dancers)
                    this.angle += 0.05;

                    // Logic Right (Soldier/Mime)
                    const radius = 20;
                    const center2X = (WIDTH/2) + (WIDTH/4);
                    const center2Y = HEIGHT/2 + 10;
                    
                    this.soldierAngle += 0.04;
                    const sX = center2X + Math.cos(this.soldierAngle) * (radius*0.8);
                    const sY = center2Y + Math.sin(this.soldierAngle) * (radius*0.4) + 5;
                    const sFlip = Math.sin(this.soldierAngle) > 0;

                    this.history.push({x:sX, y:sY, flip:sFlip});
                    if(this.history.length > 26) this.history.shift();

                    // Sweat
                    if(this.history.length >= 25 && this.frameCount % 10 === 0) {
                        const past = this.history[0];
                        this.sweat.push({ x: past.x, y: past.y-8, vx: (Math.random()-0.5), vy: -0.5-Math.random() });
                    }
                    for(let i=this.sweat.length-1; i>=0; i--) {
                        this.sweat[i].x += this.sweat[i].vx;
                        this.sweat[i].y += this.sweat[i].vy;
                        this.sweat[i].vy += 0.05;
                        if(this.sweat[i].y > HEIGHT) this.sweat.splice(i,1);
                    }

                    // Snow
                    this.snow.forEach(p => {
                        p.y += p.speed; p.x += Math.sin(this.frameCount*0.02)*0.2;
                        if(p.y>HEIGHT) p.y=0; if(p.x>WIDTH) p.x=0;
                    });
                },

                draw: function() {
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;
                    const HALF_W = WIDTH/2;
                    const centerX = HALF_W/2;
                    const centerY = HEIGHT/2 + 10;
                    const radius = 20;

                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,canvas.width, canvas.height);
                    ctx.scale(this.SCALE, this.SCALE);

                    // BG Left
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(0,0,HALF_W, HEIGHT);
                    ctx.fillStyle = '#e0f2fe'; ctx.beginPath(); ctx.ellipse(centerX, centerY+8, 28, 13, 0, 0, Math.PI*2); ctx.fill();
                    
                    // BG Right
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(HALF_W,0,HALF_W, HEIGHT);
                    ctx.fillStyle = '#e2e8f0'; ctx.beginPath(); ctx.ellipse(centerX+HALF_W, centerY+8, 28, 13, 0, 0, Math.PI*2); ctx.fill();
                    
                    // Divider
                    ctx.fillStyle = '#000'; ctx.fillRect(HALF_W-1, 0, 2, HEIGHT);

                    // --- Left Dancers ---
                    const d1X = centerX + Math.cos(this.angle)*(radius*0.7);
                    const d1Y = centerY + Math.sin(this.angle)*(radius*0.35)+5;
                    const d2X = centerX + Math.cos(this.angle+Math.PI)*(radius*0.7);
                    const d2Y = centerY + Math.sin(this.angle+Math.PI)*(radius*0.35)+5;
                    
                    const drawDancer = (x,y, frame) => {
                        ctx.fillStyle = '#f472b6'; ctx.fillRect(x-3, y+2, 7, 3); // Dress
                        ctx.fillStyle = '#fdf2f8'; ctx.fillRect(x, y-1, 1, 3); // Pale pink body
                        ctx.fillStyle = '#ffe4e6'; ctx.fillRect(x, y-3, 2, 2); // Head
                        
                        // Legs
                        ctx.fillStyle = '#ffe4e6';
                        if (Math.floor(frame / 10) % 2 === 0) {
                            ctx.fillRect(x, y+5, 1, 3); 
                        } else {
                            ctx.fillRect(x-1, y+4, 1, 2); 
                            ctx.fillRect(x+1, y+5, 1, 3);
                        }
                    };
                    
                    if (Math.sin(this.angle) < 0) { drawDancer(d1X,d1Y, this.frameCount); drawDancer(d2X,d2Y, this.frameCount); }
                    else { drawDancer(d2X,d2Y, this.frameCount); drawDancer(d1X,d1Y, this.frameCount); }
                    
                    ctx.strokeStyle = '#fbcfe8'; ctx.beginPath(); ctx.moveTo(d1X+1, d1Y+2); ctx.lineTo(d2X+1, d2Y+2); ctx.stroke();

                    // --- Right Soldier/Mime ---
                    // Current Pos
                    const center2X = centerX+HALF_W;
                    const center2Y = centerY;
                    const sX = center2X + Math.cos(this.soldierAngle) * (radius*0.8);
                    const sY = center2Y + Math.sin(this.soldierAngle) * (radius*0.4) + 5;
                    const sFlip = Math.sin(this.soldierAngle) > 0;
                    
                    const entities = [{t:'s', x:sX, y:sY, f:sFlip}];
                    if(this.history.length >= 25) {
                         const h = this.history[0];
                         entities.push({t:'m', x:h.x, y:h.y, f:h.f});
                    }
                    entities.sort((a,b)=>a.y-b.y);

                    entities.forEach(e => {
                        ctx.save(); ctx.translate(e.x, e.y); if(e.f) ctx.scale(-1,1);
                        
                        const march = Math.floor(this.frameCount / 8) % 2;
                        const ox = -2;
                        const oy = 0;

                        if(e.t==='s') {
                            // Soldier
                            // Hat
                            ctx.fillStyle = '#000'; ctx.fillRect(ox, oy-6, 4, 5);
                            ctx.fillStyle = '#fbbf24'; ctx.fillRect(ox+1, oy-4, 2, 1);
                            // Face
                            ctx.fillStyle = '#fca5a5'; ctx.fillRect(ox, oy-1, 4, 3);
                            ctx.fillStyle = '#000'; ctx.fillRect(ox+1, oy+1, 2, 1); // Mustache
                            // Coat
                            ctx.fillStyle = '#ef4444'; ctx.fillRect(ox-1, oy+2, 6, 6);
                            // Belt
                            ctx.fillStyle = '#fff'; 
                            ctx.fillRect(ox, oy+2, 1, 1); ctx.fillRect(ox+1, oy+3, 1, 1);
                            ctx.fillRect(ox+2, oy+4, 1, 1); ctx.fillRect(ox+3, oy+5, 1, 1);
                            // Legs
                            ctx.fillStyle = '#1e293b'; 
                            if (march === 0) { ctx.fillRect(ox, oy+8, 1, 4); ctx.fillRect(ox+3, oy+8, 1, 4); }
                            else { ctx.fillRect(ox, oy+7, 1, 3); ctx.fillRect(ox+3, oy+8, 1, 4); }
                        } else {
                            // Mime
                            // Beret
                            ctx.fillStyle = '#000'; ctx.fillRect(ox, oy-5, 5, 2);
                            // Face
                            ctx.fillStyle = '#fff'; ctx.fillRect(ox+1, oy-3, 3, 3);
                            // Shirt
                            ctx.fillStyle = '#fff'; ctx.fillRect(ox, oy, 5, 6);
                            ctx.fillStyle = '#334155'; ctx.fillRect(ox, oy+1, 5, 1); ctx.fillRect(ox, oy+3, 5, 1); ctx.fillRect(ox, oy+5, 5, 1);
                            // Legs
                            ctx.fillStyle = '#000';
                            if (march === 0) { ctx.fillRect(ox+1, oy+6, 1, 4); ctx.fillRect(ox+3, oy+6, 1, 4); }
                            else { ctx.fillRect(ox+1, oy+5, 1, 3); ctx.fillRect(ox+3, oy+6, 1, 4); }
                        }
                        ctx.restore();
                    });

                    // Sweat
                    ctx.fillStyle = '#0ea5e9';
                    this.sweat.forEach(p => ctx.fillRect(p.x, p.y, 1, 1));
                    
                    // Global Snow
                    ctx.fillStyle = '#fff';
                    this.snow.forEach(p => ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1));
                }
            },


            // --- GAME 3: SHUTTER SPEED (Tau) ---
            shutter: {
                frameCount: 0, SCALE: 4, tau: 0.5,
                
                init: function() {
                    canvas.height = 320;
                    this.frameCount = 0;
                    this.tau = 0.5;

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #ff0055; text-align: left; padding-left: 10px;">TARGET: SPEEDING CAR</div>
                        <div id="status-label" style="position:absolute; bottom:20px; width:100%; text-align:center; color:#fff; font-size:12px; text-shadow:2px 2px #000;">WAITING...</div>
                    `;

                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `
                         <div class="control-group">
                            <div style="display:flex; justify-content:space-between; width:100%; color:#94a3b8; font-size:10px; margin-bottom:5px;">
                                <span>Noise</span>
                                <span>Peak</span>
                                <span>Loss</span>
                            </div>
                            <input type="range" id="shutterSlider" min="0" max="100" value="50">
                            <div style="font-size:10px; color:#666; margin-top:5px; text-align:center;">ADJUST OBSERVATION TIME (&tau;)</div>
                         </div>
                    `;
                    
                    document.getElementById('shutterSlider').addEventListener('input', (e) => {
                        this.tau = parseInt(e.target.value) / 100;
                    });
                },

                update: function() {
                    this.frameCount++;
                    const lbl = document.getElementById('status-label');
                    if(this.tau < 0.2) { lbl.innerText = "NOISE DOMINANCE (Zoomed, High Entropy)"; lbl.style.color="#ef4444"; }
                    else if(this.tau > 0.8) { lbl.innerText = "MEMORY LOSS (Signal Departed)"; lbl.style.color="#64748b"; }
                    else { lbl.innerText = "CAUSAL PEAK (Signal Captured)"; lbl.style.color="#32CD32"; }
                },

                draw: function() {
                    const WIDTH = canvas.width/this.SCALE;
                    const HEIGHT = canvas.height/this.SCALE;
                    
                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    
                    // 1. Scene (Low Res)
                    ctx.scale(this.SCALE, this.SCALE);
                    
                    // BG
                    ctx.fillStyle = '#111'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,WIDTH,HEIGHT/2); // Sky
                    ctx.fillStyle = '#333'; ctx.fillRect(0,HEIGHT/2,WIDTH,HEIGHT/2); // Ground
                    
                    // Road
                    ctx.fillStyle = '#555';
                    const speed = (this.frameCount*4)%40;
                    for(let i=-40; i<WIDTH; i+=40) ctx.fillRect(i-speed, HEIGHT/2+20, 20, 2);

                    // Car Logic
                    const cx = (WIDTH/2)-15, cy = (HEIGHT/2)+10;
                    let zoom=1, blur=0, opacity=1;
                    
                    if(this.tau < 0.5) {
                        zoom = 1 + (1-(this.tau*2))*11;
                    } else {
                        const f = (this.tau-0.5)*2;
                        opacity = 1-f; blur = f*5;
                    }

                    // Draw Car
                    ctx.save();
                    if(zoom>1) {
                         ctx.translate(cx+10, cy+10); ctx.scale(zoom, zoom); ctx.translate(-(cx+10), -(cy+10));
                    }
                    const layers = 1+Math.floor(blur*10);
                    const step = blur*2;
                    for(let i=0; i<layers; i++) {
                        ctx.globalAlpha = opacity * (1-(i/layers));
                        const dx = cx - (i*step);
                        ctx.fillStyle = '#ef4444'; ctx.fillRect(dx, cy, 30, 10); // Body
                        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(dx+5, cy-6, 18, 6); // Cabin
                        ctx.fillStyle = '#93c5fd'; ctx.fillRect(dx+16, cy-5, 6, 4); // Glass
                        ctx.fillStyle = '#fbbf24'; ctx.fillRect(dx, cy+4, 30, 2); // Stripe
                        ctx.fillStyle = '#111'; ctx.fillRect(dx+4, cy+8, 6,6); ctx.fillRect(dx+20, cy+8, 6,6); // Wheels
                    }
                    ctx.restore();
                    
                    // 2. Noise (High Res)
                    ctx.setTransform(1,0,0,1,0,0);
                    if(this.tau < 0.5) {
                        const amount = (0.5-this.tau)*0.6; // max 30%
                        const id = ctx.getImageData(0,0,canvas.width,canvas.height);
                        const d = id.data;
                        for(let i=0; i<d.length; i+=4) {
                            if(Math.random()<amount) {
                                const v = Math.random()*255; d[i]=v; d[i+1]=v; d[i+2]=v;
                            }
                        }
                        ctx.putImageData(id, 0,0);
                    }
                }
            },


            // --- GAME 4: THE WANDERER (Rope Physics) ---
            wanderer: {
                frameCount:0, SCALE:2,
                ropeLen: 40, wSpeed: 2,
                wanderer: {x:0, y:0, a:0, ta:0, t:0},
                sled: {x:0, y:0, a:0},
                particles: [], totalHeat: 0,
                snowCanvas: null, snowCtx: null,

                init: function() {
                    canvas.height = 360; // Larger height for this one
                    this.frameCount = 0;
                    this.totalHeat = 0;
                    this.particles = [];
                    this.ropeLen = 40;
                    this.wSpeed = 2;

                    const WIDTH = canvas.width; 
                    const HEIGHT = canvas.height; 

                    this.wanderer = {x:WIDTH/2, y:HEIGHT/2, a:0, ta:0, t:0};
                    this.sled = {x:WIDTH/2, y:HEIGHT/2+40, a:0};

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #1e3a8a;">
                            <span>Signal (x)</span>
                            <span>Response (y)</span>
                        </div>
                        <div class="ui-label-bottom">
                            <span id="wand-math">Heat &Phi; &ge; Info T</span>
                        </div>
                    `;

                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `
                         <div class="control-group">
                            <label style="color:#94a3b8; font-size:10px;">Rope Length (Lag)</label>
                            <input type="range" id="ropeSlider" min="10" max="100" value="40">
                         </div>
                         <div class="control-group">
                            <label style="color:#94a3b8; font-size:10px;">Wanderer Speed</label>
                            <input type="range" id="speedSlider" min="1" max="10" value="3">
                         </div>
                    `;

                    document.getElementById('ropeSlider').addEventListener('input', e => this.ropeLen=parseInt(e.target.value));
                    document.getElementById('speedSlider').addEventListener('input', e => this.wSpeed=parseInt(e.target.value));
                    
                    // Create an offscreen canvas for persistent tracks
                    this.snowCanvas = document.createElement('canvas');
                    this.snowCanvas.width = WIDTH;
                    this.snowCanvas.height = HEIGHT;
                    this.snowCtx = this.snowCanvas.getContext('2d');
                    this.snowCtx.fillStyle = '#f0f9ff';
                    this.snowCtx.fillRect(0,0,WIDTH,HEIGHT);
                },

                update: function() {
                    this.frameCount++;
                    const WIDTH = canvas.width;
                    const HEIGHT = canvas.height;

                    // Wanderer
                    if(this.frameCount > this.wanderer.t) {
                        this.wanderer.ta = Math.random()*Math.PI*2;
                        this.wanderer.t = this.frameCount + 30 + Math.random()*60;
                    }
                    const diff = this.wanderer.ta - this.wanderer.a;
                    this.wanderer.a += diff*0.05;
                    this.wanderer.x += Math.cos(this.wanderer.a)*this.wSpeed;
                    this.wanderer.y += Math.sin(this.wanderer.a)*this.wSpeed;
                    
                    // Bounds
                    if(this.wanderer.x < 20 || this.wanderer.x > WIDTH-20) { this.wanderer.a = Math.PI - this.wanderer.a; this.wanderer.x = Math.max(20, Math.min(WIDTH-20, this.wanderer.x)); }
                    if(this.wanderer.y < 20 || this.wanderer.y > HEIGHT-20) { this.wanderer.a = -this.wanderer.a; this.wanderer.y = Math.max(20, Math.min(HEIGHT-20, this.wanderer.y)); }

                    // Sled
                    const dx = this.wanderer.x - this.sled.x;
                    const dy = this.wanderer.y - this.sled.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    let heatGen = 0;

                    if(dist > this.ropeLen) {
                        const angle = Math.atan2(dy, dx);
                        const tx = this.wanderer.x - Math.cos(angle)*this.ropeLen;
                        const ty = this.wanderer.y - Math.sin(angle)*this.ropeLen;
                        
                        const mx = (tx - this.sled.x)*0.1;
                        const my = (ty - this.sled.y)*0.1;
                        
                        const prevX = this.sled.x;
                        const prevY = this.sled.y;
                        this.sled.x += mx; this.sled.y += my;
                        this.sled.a = Math.atan2(my, mx);

                        // Tracks
                        this.snowCtx.strokeStyle = '#cbd5e1'; this.snowCtx.lineWidth=6; this.snowCtx.lineCap='round';
                        this.snowCtx.beginPath(); this.snowCtx.moveTo(prevX, prevY); this.snowCtx.lineTo(this.sled.x, this.sled.y); this.snowCtx.stroke();

                        // Heat
                        const moved = Math.sqrt(mx*mx+my*my);
                        heatGen = moved * 2;
                        if(moved > 0.5) {
                            for(let i=0; i<Math.floor(moved); i++) {
                                this.particles.push({x:this.sled.x, y:this.sled.y, vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2, life:1});
                            }
                        }
                    }

                    this.totalHeat += heatGen;
                    document.getElementById('wand-math').innerText = `Entropy Generated (\u03A6): ${Math.floor(this.totalHeat)}`;

                    // Particles
                    for(let i=this.particles.length-1; i>=0; i--) {
                        let p = this.particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
                        if(p.life<=0) this.particles.splice(i,1);
                    }
                },

                draw: function() {
                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.drawImage(this.snowCanvas, 0, 0);

                    // Rope
                    ctx.strokeStyle = '#0f172a'; ctx.lineWidth=2; ctx.setLineDash([4,4]);
                    ctx.beginPath(); ctx.moveTo(this.wanderer.x, this.wanderer.y); ctx.lineTo(this.sled.x, this.sled.y); ctx.stroke(); ctx.setLineDash([]);

                    // Sled
                    ctx.save(); ctx.translate(this.sled.x, this.sled.y); ctx.rotate(this.sled.a);
                    ctx.fillStyle = '#0284c7'; ctx.fillRect(-10,-5,20,10);
                    ctx.fillStyle = '#0c4a6e'; ctx.fillRect(-10,-8,20,2); ctx.fillRect(-10,6,20,2);
                    ctx.restore();

                    // Wanderer
                    ctx.save(); ctx.translate(this.wanderer.x, this.wanderer.y);
                    const bob = Math.sin(this.frameCount*0.2)*2;
                    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(0,10,8,4,0,0,Math.PI*2); ctx.fill(); // Shadow
                    ctx.fillStyle = '#dc2626'; ctx.fillRect(-6, -10+bob, 12, 14); // Body
                    ctx.fillStyle = '#fecaca'; ctx.fillRect(-4, -18+bob, 8, 8); // Head
                    ctx.fillStyle = '#991b1b'; ctx.fillRect(-5, -20+bob, 10, 4); // Hat
                    ctx.restore();

                    // Heat
                    ctx.fillStyle = '#f59e0b';
                    this.particles.forEach(p => { ctx.globalAlpha=p.life; ctx.fillRect(p.x, p.y, 2, 2); });
                    ctx.globalAlpha = 1;
                }
            },
            
            // --- GAME 5: RUDOLPH'S PIPE TROUBLE (Non-Linear Model) ---
            chimney: {
                frameCount: 0, SCALE: 2,
                wandererX: 320, sledX: 320,
                targetWandererX: 320, wandererTimer: 0,
                particles: [], totalHeat: 0,
                stickiness: 2, wandererAmp: 1,

                init: function() {
                    canvas.height = 360;
                    this.frameCount = 0;
                    this.totalHeat = 0;
                    this.particles = [];
                    this.wandererX = 320;
                    this.sledX = 320;
                    this.stickiness = 2; // Threshold force to move
                    this.wandererAmp = 1; // Range multiplier

                    // UI
                    uiLayer.innerHTML = `
                        <div class="ui-label-top" style="color: #4ade80;">
                            <span>Wall (0)</span>
                            <span>The Tube</span>
                            <span>Wall (1)</span>
                        </div>
                        <div class="ui-label-bottom">
                            <span id="chimney-status">Status: EQUILIBRIUM</span>
                        </div>
                    `;

                    controlsArea.style.display = 'flex';
                    controlsArea.innerHTML = `
                        <div class="control-group">
                            <label style="color:#94a3b8; font-size:10px;">Flight Range</label>
                            <input type="range" id="ampSlider" min="1" max="50" value="10">
                        </div>
                        <div class="control-group">
                            <label style="color:#94a3b8; font-size:10px;">Pipe Tightness</label>
                            <input type="range" id="stickSlider" min="0" max="10" value="2">
                        </div>
                    `;

                    document.getElementById('ampSlider').addEventListener('input', e => this.wandererAmp = parseInt(e.target.value) / 10);
                    document.getElementById('stickSlider').addEventListener('input', e => this.stickiness = parseInt(e.target.value));
                },

                update: function() {
                    this.frameCount++;
                    const WIDTH = canvas.width;
                    const CENTER = WIDTH / 2;
                    const CHIMNEY_WIDTH = 120;
                    const WALL_L = CENTER - CHIMNEY_WIDTH/2;
                    const WALL_R = CENTER + CHIMNEY_WIDTH/2;

                    // 1. Update Rudolph (The Signal)
                    if (this.frameCount > this.wandererTimer) {
                        const range = 200 * this.wandererAmp; 
                        this.targetWandererX = CENTER + (Math.random() - 0.5) * 2 * range;
                        this.wandererTimer = this.frameCount + 60 + Math.random() * 60;
                    }
                    const dx = this.targetWandererX - this.wandererX;
                    this.wandererX += dx * 0.02; 

                    // 2. Physics: Rope Tension & Stickiness
                    const tension = (this.wandererX - this.sledX) * 0.1;
                    let velocity = 0;

                    if (Math.abs(tension) > this.stickiness) {
                        velocity = (Math.abs(tension) - this.stickiness) * Math.sign(tension);
                    }

                    // 3. Move Present
                    const prevSledX = this.sledX;
                    this.sledX += velocity;

                    // 4. Saturation (Walls)
                    let hitWall = false;
                    if (this.sledX <= WALL_L) { this.sledX = WALL_L; hitWall = true; }
                    if (this.sledX >= WALL_R) { this.sledX = WALL_R; hitWall = true; }

                    // 5. Thermodynamics (Heat Generation)
                    const movedDist = Math.abs(this.sledX - prevSledX);
                    let heatFrame = 0;
                    
                    if (movedDist > 0.1) {
                         heatFrame = movedDist * 5; 
                         for(let i=0; i<Math.floor(heatFrame); i++) {
                             this.particles.push({
                                 x: this.sledX + (Math.random()-0.5)*20, 
                                 y: 180 + (Math.random()-0.5)*20, 
                                 vx: (Math.random()-0.5)*4, 
                                 vy: (Math.random()-0.5)*4, 
                                 life: 1.0, color: '#fef3c7' // Dust/Sparks
                             });
                         }
                    }

                    const statusLbl = document.getElementById('chimney-status');
                    if (hitWall) {
                        statusLbl.innerText = "Status: SATURATED (Blindness)";
                        statusLbl.style.color = "#ef4444";
                    } else if (movedDist > 0.1) {
                        statusLbl.innerText = "Status: DRAGGING";
                        statusLbl.style.color = "#fbbf24";
                    } else {
                        statusLbl.innerText = "Status: STUCK (Sub-Threshold)";
                        statusLbl.style.color = "#64748b";
                    }

                    for(let i=this.particles.length-1; i>=0; i--) {
                        let p = this.particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
                        if(p.life<=0) this.particles.splice(i,1);
                    }
                },

                draw: function() {
                    const WIDTH = canvas.width;
                    const HEIGHT = canvas.height;
                    const CENTER = WIDTH / 2;
                    const CHIMNEY_WIDTH = 120;
                    const WALL_L = CENTER - CHIMNEY_WIDTH/2;
                    const WALL_R = CENTER + CHIMNEY_WIDTH/2;
                    
                    ctx.setTransform(1,0,0,1,0,0);
                    ctx.clearRect(0,0,WIDTH,HEIGHT);
                    
                    // Background
                    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,WIDTH,HEIGHT); 
                    
                    // The Pipe (Inner Void)
                    ctx.fillStyle = '#000'; ctx.fillRect(WALL_L, 0, CHIMNEY_WIDTH, HEIGHT);
                    
                    // Draw Pipe Structure
                    ctx.fillStyle = '#22c55e'; // Light Green
                    ctx.fillRect(WALL_L-40, 0, 40, HEIGHT); // Left Wall Body
                    ctx.fillRect(WALL_R, 0, 40, HEIGHT);   // Right Wall Body
                    
                    ctx.fillStyle = '#15803d'; // Dark Green Outline
                    ctx.fillRect(WALL_L, 0, 4, HEIGHT);
                    ctx.fillRect(WALL_R-4, 0, 4, HEIGHT);
                    ctx.fillRect(WALL_L-40, 0, 4, HEIGHT);
                    ctx.fillRect(WALL_R+36, 0, 4, HEIGHT);

                    // Draw Rope
                    ctx.beginPath();
                    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;
                    ctx.moveTo(this.wandererX, 100); 
                    ctx.lineTo(this.sledX, 180);     
                    ctx.stroke();

                    // Draw Rudolph (The Signal)
                    const rx = this.wandererX;
                    const ry = 100;
                    ctx.save(); ctx.translate(rx, ry);
                    
                    // Body
                    ctx.fillStyle = '#92400e'; ctx.fillRect(-10, -6, 20, 12);
                    // Head
                    ctx.fillStyle = '#b45309'; ctx.fillRect(8, -10, 10, 10);
                    // Nose (Glowing Red)
                    ctx.fillStyle = '#ef4444'; 
                    ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.arc(18, -5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0;
                    // Antlers
                    ctx.fillStyle = '#fcd34d'; 
                    ctx.fillRect(10, -14, 2, 4); ctx.fillRect(14, -14, 2, 4);
                    // Legs (Simple bobbing)
                    const legOff = Math.sin(this.frameCount*0.5)*3;
                    ctx.fillStyle = '#92400e'; 
                    ctx.fillRect(-8, 6+legOff, 4, 6); ctx.fillRect(4, 6-legOff, 4, 6);

                    ctx.restore();
                    ctx.fillStyle = '#fff'; ctx.font = "10px monospace"; ctx.fillText("RUDOLPH", rx-20, ry-30);

                    // Draw Present (The Response)
                    const px = this.sledX;
                    const py = 180;
                    ctx.save(); ctx.translate(px, py);
                    // Box
                    ctx.fillStyle = '#dc2626'; ctx.fillRect(-12, -12, 24, 24);
                    // Ribbon (Gold Cross)
                    ctx.fillStyle = '#fcd34d'; 
                    ctx.fillRect(-4, -12, 8, 24); // Vertical
                    ctx.fillRect(-12, -4, 24, 8); // Horizontal
                    // Bow
                    ctx.beginPath(); ctx.arc(0, -12, 6, 0, Math.PI, true); ctx.fill();
                    ctx.restore();

                    // Draw Particles (Dust/Sparks)
                    this.particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.fillRect(p.x, p.y, 3, 3);
                    });
                    ctx.globalAlpha = 1.0;
                }
            }
        };

    </script>
</body>
</html>
